# Linux

## 系统目录结构
| 目录 | 作用 |
| -- | -- |
| /bin | 是 Binaries (二进制文件) 的缩写，这个目录存放着最经常使用的命令。|
|/boot| 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件|
| /etc | etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 |
| /home | 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的 |
| /lib | lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 |
| /lost-found | 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件 |
| /media | linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 |
| /mnt | 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 |
| /opt | opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 |
| /proc | proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。 |
| /root | 该目录为系统管理员，也称作超级权限者的用户主目录。 |
| /sbin | s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 |
| /usr |  usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 |
| /usr/bin | 系统用户使用的应用程序。 |
| /usr/sbin | 超级用户使用的比较高级的管理程序和系统守护程序。 |
| /usr/src | 内核源代码默认的放置目录。 |
| /var | var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 |
| /run | 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 |
| /srv | 该目录存放一些服务启动之后需要提取的数据。 |
| /sys | 这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。|
| /tmp | tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。

### Linux 系统文件类型
| 文件类型 | 符号
| -- | -- |
|普通文件|-|
|目录文件|d|
|字符设备文件|c|
|块设备文件|b|
|软链接|l|
|管道文件|p|
|套接字|s|

#### 软链接
```
    ln -s 源文件路径 链接文件名
```
如果希望创建出来的链接文件可任意移动，则需指定源文件路径为绝对路径。

#### 硬链接
硬链接对其一个文件修改，会影响到其他文件。每链接一个文件，硬链接计数+1。底层每个硬链接文件的inode 是一样的。删除的时候，先减硬链接计数。当硬链接计数变为1的时候，指向 inode 的文件便不存在。
```
    ln 源文件 链接文件
```

## 进程间通信

### 管道
Linux 为管道提供了环形缓冲队列的管理机制，并提供了同步和互斥访问。

管道是一种最基本的 IPC 机制，作用于有血缘关系的进程之间，完成数据传递，调用 pipe 系统函数即可创建一个管道，由如下特质：
1. 其本质是一个伪文件（实为内核缓冲区）
2. 由两个文件描述符引用，一个表示读端，一个表示写端
3. 规定数据从管道的写端流入管道，从读端流出。

管道的原理：管道实为内核使用环形队列机制，借助内核缓冲区（4k)实现。
管道的局限性：
1. 数据不能进程自己写，自己读。
2. 管道中数据不可反复读取，一旦读走，管道中不再存在。
3. 采用半双工通信方式，数据只能在单方向流动。
4. 血缘关系进程间可用。

管道读写行为
1. 读管道
   1. 管道中有数据，read 返回实际读到的字节数
   2. 管道中无数据
      1. 管道写端被全部关闭，read 返回 0，类似读到文件尾。
      2. 写端没有全部被关闭，read 会阻塞等待。
2. 写管道
   1. 管道读端全部被关闭，进程异常终止。（也可以使用 SIGPIPE 信号，使进程不终止）
   2. 管道读端没有全部关闭：
      1. 管道已满，write 阻塞。
      2. 管道未满，write 将数据写入，并返回实际写入的字节数。


##### 匿名管道 PIPE

##### 命名管道 FIFO

文件实现进程间通信：打开的文件是内核中的一块缓冲区。多个无血缘关系的进程，可以同时访问该文件。

### 共享内存映射
相对于管道来说，共享内存映射偏原始，Linux 不会为它做任何数据管理工作，也没有同步与互斥机制，需要应用程序自己控制。
```
// 创建共享内存映射
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);		
参数：
    addr： 	指定映射区的首地址。通常传NULL，表示让系统自动分配
    length：共享内存映射区的大小。（<= 文件的实际大小）
    prot：	共享内存映射区的读写属性。PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE
    flags：	标注共享内存的共享属性。MAP_SHARED、MAP_PRIVATE
    fd:	用于创建共享内存映射区的那个文件的 文件描述符。
    offset：默认0，表示映射文件全部。偏移位置。需是 4k 的整数倍。
返回值：
    成功：映射区的首地址。
    失败：MAP_FAILED (void*(-1))， errno

// 释放映射区。
int munmap(void *addr, size_t length);
	addr：mmap 的返回值
	length：大小
```

使用注意事项：
1. 用于创建映射区的文件大小为 0，实际指定非0大小创建映射区，出 “总线错误”。
2. 用于创建映射区的文件大小为 0，实际制定0大小创建映射区， 出 “无效参数”。
3. 用于创建映射区的文件读写属性为，只读。映射区属性为 读、写。 出 “无效参数"
4. 创建映射区，需要read权限。当访问权限指定为 “共享”MAP_SHARED是， mmap的读写权限，应该 <=文件的open权限。	只写不行。
5. 文件描述符fd，在mmap创建映射区完成即可关闭。后续访问文件，用 地址访问。
6. offset 必须是 4096的整数倍。（MMU 映射的最小单位 4k ）
7. 对申请的映射区内存，不能越界访问。 
8. munmap用于释放的 地址，必须是mmap申请返回的地址。
9. 映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。
10.  映射区访问权限为 “私有”MAP_PRIVATE, 只需要open文件时，有读权限，用于创建映射区即可。

mmap函数的保险调用方式：
```
    1. fd = open（"文件名"， O_RDWR）;
    2. mmap(NULL, 有效文件大小， PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
```

匿名映射：只能用于 血缘关系进程间通信。
```
    p = (int *)mmap(NULL, 40, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
```

### 套接字

## 信号

```
1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     17) SIGCHLD
18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN
22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO
30) SIGPWR      31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1
36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4  39) SIGRTMIN+5
40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8  43) SIGRTMIN+9
44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13
52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9
56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6  59) SIGRTMAX-5
60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2  63) SIGRTMAX-1
64) SIGRTMAX
```

列表中，编号为1 ~ 31的信号为传统UNIX支持的信号，是不可靠信号(非实时的)，编号为32 ~ 63的信号是后来扩充的，称做可靠信号(实时信号)。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。

下面我们对编号小于SIGRTMIN的信号进行讨论。 

1. SIGHUP
   本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录，wget也能继续下载。此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。

2) SIGINT
   程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。
3. SIGQUIT
   和SIGINT类似, 但由QUIT字符(通常是Ctrl-/)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。

4) SIGILL
   执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。

5. SIGTRAP
   由断点指令或其它trap指令产生. 由debugger使用。

6) SIGABRT
   调用abort函数生成的信号。

7. SIGBUS
   非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。

8) SIGFPE
   在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。

9.  SIGKILL
    用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。

10) SIGUSR1
    留给用户使用

11. SIGSEGV
    试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.

12) SIGUSR2
    留给用户使用

13. SIGPIPE
    管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。

14) SIGALRM
    时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号.

15. SIGTERM
    程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。

17) SIGCHLD
    子进程结束时, 父进程会收到这个信号。如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程来接管)。默认动作为忽略。

18.  SIGCONT
   让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符。

19)  SIGSTOP
    停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略.

20. SIGTSTP
    停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号

21) SIGTTIN
    当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行.

22. SIGTTOU
    类似于SIGTTIN, 但在写终端(或修改终端模式)时收到.

23) SIGURG
    有"紧急"数据或out-of-band数据到达socket时产生.

24. SIGXCPU
    超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。

25) SIGXFSZ
    当进程企图扩大文件以至于超过文件大小资源限制。

26. SIGVTALRM
    虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.

27) SIGPROF
    类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间.

28. SIGWINCH
    窗口大小改变时发出.

29) SIGIO
    文件描述符准备就绪, 可以开始进行输入/输出操作.

30. SIGPWR
    Power failure

31) SIGSYS
    非法的系统调用。

+ 在以上列出的信号中，程序不可捕获、阻塞或忽略的信号有：SIGKILL,SIGSTOP
+ 不能恢复至默认动作的信号有：SIGILL,SIGTRAP
+ 默认会导致进程流产的信号有：SIGABRT,SIGBUS,SIGFPE,SIGILL,SIGIOT,SIGQUIT,SIGSEGV,SIGTRAP,SIGXCPU,SIGXFSZ
+ 默认会导致进程退出的信号有：SIGALRM,SIGHUP,SIGINT,SIGKILL,SIGPIPE,SIGPOLL,SIGPROF,SIGSYS,SIGTERM,SIGUSR1,SIGUSR2,SIGVTALRM
+ 默认会导致进程停止的信号有：SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU
+ 默认进程忽略的信号有：SIGCHLD,SIGPWR,SIGURG,SIGWINCH

此外，SIGIO在SVR4是退出，在4.3BSD中是忽略；SIGCONT在进程挂起时是继续，否则是忽略，不能被阻塞。 


#### 信号四要素
1. 编号（Signal）
2. 名称（Value）
3. 事件（Action）
4. 默认处理动作（Comment）


## 会话

### 创建会话
创建一个会话需要注意以下几点
+ 调用进程不能是进程组组长，该进程变成新会话首进程。
+ 该进程成为一个新进程组的组长进程。
+ 如果该调用进程是组长进程，则出错返回。
+ 新会话丢弃原有的控制终端，该会话没有控制终端。
+ 需有 root 权限。（ubuntu 不需要）

### 守护进程：
daemon进程。通常运行与操作系统后台，脱离控制终端。一般不与用户直接交互。周期性的等待某个事件发生或周期性执行某一动作。
不受用户登录注销影响。通常采用以d结尾的命名方式。
守护进程创建步骤：
1. fork子进程，让父进程终止。
2. 子进程调用 setsid() 创建新会话
3. 通常根据需要，改变工作目录位置 chdir()， 防止目录被卸载。
4. 通常根据需要，重设umask文件权限掩码，影响新文件的创建权限。  022 -- 755	0345 --- 432   r---wx-w-   422
5. 通常根据需要，关闭/重定向 文件描述符
6. 守护进程 业务逻辑。while（）


## 网络

### TCP 协议

#### 三次握手
+ 主动发起连接请求段，发送 SYN 标志位，请求建立连接，携带序号、数据字节数(0)、滑动窗口大小。
+ 被动接受连接请求端，发送 ACK 标志位，同时携带 SYN 请求标志位，携带序号、确认序号、数据字节数(0)、滑动窗口大小。
+ 主动发起连接连接端。发送 ACK 标志位，应答服务器连接请求，携带确认序号。
  
#### 四次挥手
+ 主动关闭连接请求端，发送 FIN 标志位
+ 被动关闭连接请求端，应答 ACK 标志位  --- 半关闭状态
+ 被动关闭连接请求端，发送 FIN 标志位
+ 主动关闭连接请求端，应答 ACK 标志位  --- 连接全部

#### 滑动窗口
发送给连接对端，本端的缓冲区大小（实时），保证数据不会丢失。