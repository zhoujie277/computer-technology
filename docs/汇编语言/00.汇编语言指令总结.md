# 汇编语言指令总结
8086CPU 提供以下几大类命令。

## 一、MASM 汇编编译器中的伪指令
### segment 和 ends
segment 和 ends 是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。segment 和 ends 的功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束，一个段必须有一个名称来标识，使用格式为：
```
    段名 segment
    段名 ends
```
一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或被当作栈空间来使用。一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。

### end
end 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了指令end，就结束对源程序的编译。<br/>
end 除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。比如
```
    start: ...
    end start           ; 告诉编译器程序入口在标号 start 处，编译器会将该信息转换成可执行文件中的描述信息，进而在程序加载时，修改 CS:IP 的值
```

### assume
这条伪指令的含义为“假设”。它假设某一段寄存器和程序中的某一个用 segment...ends 定义的段相联。通过 assume 说明这种关联，在需要的情况下，编译器可以将段寄存器和某一个具体的段相联系。

### dd、db、dw
db 定义字节型数据。dw 定义字型数据。dd 定义双字型数据。比如
```
    data segment
    db 1            ; 第一个数据为 01H，在 data:0 处，占 1 个字节；
    dw 1            ; 第二个数据为 0001H，在 data:0 处，占 1 个字;
    dd 1            ; 第三个数据为 00000001H，在 data:3处，占 2 个字。
    data ends
```

### dup
dup 是一个操作符，它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复，比如：
```
    db 3 dup (0)                ; 相当于 db 0, 0, 0
    db 3 dup (0, 1, 2)          ; 相当于 db 0, 1, 2, 0, 1, 2, 0, 1, 2
    db 重复的次数 dup (重复的字节型数据)
    dw 重复的次数 dup (重复的字型数据)
    dd 重复的次数 dup (重复的双字型数据)
```

### offset
操作符 offset 它的功能是取得标号的偏移地址。比如下面的程序:
```
    assume cs:codesg
    codesg segment
        start: mov ax, offset start         ; 相当于 mov, ax, 0
            s: mov ax, offset s             ; 相当于 mov ax, 3
    codesg ends
    end start
```

## 二、数据传送指令
比如，mov、push、pop、pushf、popf、xchg等都是数据传送指令，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。

### MOV 指令
```
    mov ax, bx                      ;将寄存器 BX 的内容送到 AX 中
    mov 寄存器, 数据                  ;将数据送入寄存器中
    mov 寄存器, 内存单元               ;将内存单元中的数据送入寄存器中
    mov 内存单元，寄存器
    mov 段寄存器，寄存器
    mov 寄存器，段寄存器
```

### PUSH 指令
```
    push 寄存器                      ;将一个寄存器中的数据入栈
    push 段寄存器
    push 内存单元
```

### POP 指令
```
    pop 寄存器                       ;出栈，用一个寄存器接收出栈的数据
    pop 段寄存器
    pop 内存单元
```

### PUSHF/POPF 指令
pushf 的功能是将标志寄存器的值压栈，而 popf 是从栈中弹出数据，送入标志寄存器中。指令格式如下:

    pushf
    popf

### xchg

## 三、算数运算指令
比如，add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa等都是基本运算指令，这些指令实现寄存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器中的zf、sf、of、cf、pf、af位。

### ADD 指令
```
    add ax, bx                      ;将寄存器 AX 和 BX 中的数值相加，结果存在 AX 中
    add 寄存器，数据
    add 寄存器，寄存器
    add 寄存器，内存单元
    add 内存单元，寄存器
```

### SUB 指令
```
    sub ax, bx                      ;将寄存器 AX 和 BX 中的数值相减，结果存在 AX 中
    sub 寄存器，数据
    sub 寄存器，寄存器
    sub 寄存器，内存单元
    sub 内存单元，寄存器
```

### DIV 指令
div 是除法指令，使用 div 做除法的时候应注意以下问题：
+ 除数：有 8 位和 16 位两种，在一个 reg 或内存单元中
+ 被除数：默认放在 AX 或 DX 和 AX 中，如果除数为 8 位，被除数则为 16 位，默认在 AX 中存放；如果除数为 16 位，被除数为 32 位，在 DX 或 AX 中存放，DX 存放为高 16 位，AX 存放低 16 位。
+ 结果：如果除数为 8 位，则 AL 存储出发操作的商，AH 存储除法操作的余数; 如果除数为 16 位，则 AX 存储除法操作的商，DX 中存储除法操作的余数。

格式如下：
```
    div reg             ; 除数存放在寄存器中
    div 内存单元         ; 除数存放在内存单元中
```

### MUL 指令
mul 是乘法指令，使用 mul 做乘法的时候，注意一下两点。
1. 两个相乘的数，要么都是 8 位，要么都是 16 位。如果是 8 位，一个默认放在 AL 中，另一个放在 8 位 reg 或内存字节单元中；如果是 16 位，一个默认在 AX 中，另一个放在 16 位 reg 或内存字单元中。
2. 结果：如果是 8 位乘法，结果默认放在 AX 中；如果是 16 位乘法，结果高位默认在 DX 中存放，低位在 AX 中存放。

```
    mul reg
    mul 内存单元
    mul byte ptr ds:[0]
    mul word ptr [bx + si + 8]
```

### ADC 指令
adc 是带进位的加法指令，它利用了 CF 位上记录的进位值。指令格式：

    adc 操作对象 1, 操作对象 2                  ; 操作对象 1 = 操作对象 1 + 操作对象 2 + CF

### SBB 指令
sbb 是带借位减法指令，它利用了 CF 位上记录的借位值。指令格式：

    sbb 操作对象 1， 操作对象 2                 ; 操作对象 1 = 操作对象 1 - 操作对象 2 - CF

## 四、逻辑指令
比如，and、or、not、xor、test、shr、sal、sar、rol、ror、rcl、rcr等都是逻辑指令。除了not指令外，它们的执行结果都影响标志寄存器的相关标志位。

### AND/OR 指令
and 指令，逻辑与指令，按位进行与运算。<br/>
or 指令，逻辑或指令，按位进行或运算

### SHL/SHR 逻辑移位指令
shl 和 shr 是逻辑移位指令，后面的课程中我们要用到移位指令，这里进行一下讲解。
shl 是逻辑左移指令，它的功能为：
+ 将一个寄存器或内存单元中的数据向左移位;
+ 将最后移出的一位写入 CF 中;
+ 最低位用 0 补充。

shr 是逻辑右移指令，它和shl所进行的操作刚好相反。
+ 将一个寄存器或内存单元中的数据向右移位。
+ 将最后移出的一位写入 CF 中;
+ 最高位用 0 补充。

## 五、转移指令
可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令。转移指令分为以下几类。
+ 无条件转移指令，比如，jmp；
+ 条件转移指令，比如，jcxz，je、jb、ja、jnb、jna等
+ 循环指令，比如：loop；
+ 过程，比如，call，ret，retf;
+ 中断，比如，int，iret；

### JMP 指令
jmp 为无条件转移指令，可以只修改 IP，也可以同时修改 CS 和 IP。jmp 指令要给出两种信息：
1. 转移的目的地址
2. 转移的距离（段间转移、段内短转移、段内近转移）

```
    jmp 段地址：偏移地址        ;用指令中给出的段地址修改 CS，偏移地址修改 IP。
    jmp short 标号            ;段内短转移，它对 IP 的修改范围为 -128 ～ 127，转到标号处执行指令。
    jmp near ptr 标号         ;段内近转移，位移为 16 位位移，范围在 -32768 ~ 32767。
    jmp far ptr 标号          ;实现的是段间转移，又称为远转移。用标号所在段的段地址修改 CS，用标号在段中的偏移地址修改 IP。
    jmp 16位 reg              ;修改IP。转移目的地偏移地址
    jmp word ptr 内存单元地址（段内转移）           ;从内存单元地址处开始存放着一个字，是转移的目的偏移地址。
    jmp dword ptr 内存单元地址（段间转移）          ;从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。
```

### LOOP 指令
loop 指令都是循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对 IP 的修改范围为：-128 ～ 127。CPU 执行 loop 指令的时候，要进行两步操作。
+ (cx) = (cx) - 1;
+ 判断 cx 中的值，不为零则跳转至标号处，为零则向下执行。

```
loop 指令的格式是:
    loop 标号
```

### JCXZ 指令
jcxz 为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对 IP 的修改范围都为：-128 ～ 127。指令格式如下:

    jcxz  标号                          ; 如果 (cx) = 0, 转移到标号处执行。

### CALL 指令
CPU 执行 call 指令时，进行两步操作;
+ 将当前的 IP 或 CS 和 IP 压入栈中;
+ 转移。

    call 标号               ; 相当于 push IP; jmp near ptr 标号
    call far ptr 标号       ; 实现的是段间转移。
    call 16位 reg           ; 相当于 push IP; jmp 16位reg
    call word ptr 内存单元地址          ; 相当于 push IP; jmp word ptr 内存单元地址
    call dword ptr 内存单元地址         ; 相当于 push CS; push IP; jmp dword ptr 内存单元地址

### RET/RETF 指令
ret 指令用栈中的数据，修改 IP 的内容，从而实现近转移;
retf 指令用栈中的数据，修改 CS 和 IP 的内容，从而实现远转移。

### INT/IRET 指令
int 指令的格式为: int n，n 为中断类型码，它的功能是引发中断过程。CPU 执行 int n 指令，相当于引发一个 n 号中断的中断过程，执行过程如下。
+ 取得中断类型码 n；
+ 标志寄存器入栈，TF = 0，IF = 0；
+ CS、IP 入栈
+ (IP) = (n * 4), (CS) = (n * 4 + 2)。

iret 指令的功能用汇编语法描述为
+ pop CS
+ pop CS
+ popf

### 条件转移指令

|  指令   | 含义         |  检测的相关标志位 | 指令英文全称
|  ----  | -----------  | ------ | ----------
|  je    | 等于则转移    | zf = 1  | jmp equal
|  jne   | 不等于则转移   | zf = 0 | jmp not equal
|  jb    | 低于则转移    | cf = 1  | jmp below
|  jnb   | 不低于则转移   | cf = 0 | jmp not below
|  ja    | 高于则转移    | cf = 0 且 zf = 0 | jmp above
|  jna   | 不高于则转移   | cf = 1 且 zf = 1| jmp not above

### 条件传送指令
条件转移指令和传送指令相结合的产物，既有条件转移指令的多样性，又执行的是传送操作。但是，和 mov 指令不同的是，它的目的操作数只允许是 16 位或者 32 位通用寄存器，源操作数只能是相同宽度的通用寄存器和内存单元，以下是几个常用的例子：
```
    cmovz ax, cx            ;为零则传送
    cmovnz eax, [0x2000]    ;不为零则传送
    cmove ebx, ecx          ;相等则传送
    cmovng cx, [0x1000]     ;不大于则传送
    cmovl edx, ecx          ;小于则传送
```

## 六、比较指令

### CMP 指令
cmp 是比较指令，cmp 的功能相当于减法指令，只是不保存结果。cmp 指令执行后，将对标志寄存器产生影响，其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。其他相关指令大多是条件转移转移指令，参见上文表格。指令格式：

    cmp 操作对象 1， 操作对象 2                         ; 计算操作对象 1 - 操作对象 2，但不保存结果，仅仅根据计算结果对标志寄存器进行设置。

### 字符串比较指令
```
    cmpsb               ;字节比较
    cmpsw               ;字比较
    cmpsd               ;双字比较
```
在 16 位模式中，源字符串的首地址由 DS:SI 指定，目的字符串的首地址由 ES:DI 指定；在 32 位模式下，其分别是 DS:ESI 和 ES:EDI。在处理器内部，cmps 指令的操作是把两个操作数详见，然后根据结果设置标志寄存器中相应的标志位。

取决于标志寄存器 EFLAGS 中的 DF 位，如果 DF = 0，表明是正向比较，也就是按地址递增的方向比较，这些指令执行后，SI（ESI）和 DI（EDI）的内容分别加1，加2 和加4；否则，如果 DF = 1，表明是反向比较，这些指令执行后，SI（ESI）和 DI（EDI）的内容分别减 1，减 2 和减 4。
单纯的 cmps 指令只比较一次。需要使用指令前缀 repe/repne 才能使比较连续进行，连续比较次数由 CX(ECX）寄存器控制。

## 七、处理机控制指令
这些指令对标志寄存器或其他处理机状态进行设置，比如 cld、std、cli、sti、nop、cls、cms、stc、hlt、wait、esc、lock等都是处理机控制指令。

### CLD/STD 指令

    cld             ;设置 df = 0, 正向传送
    std             ;设置 df = 1, 逆向传送

### CLI/STI 指令
如果在中断处理程序中需要处理可屏蔽中断，可以用指令将 IF 置 1. 8086CPU 提供的设置 IF 的指令如下：

    sti         ; 设置 IF = 1
    cli         ; 设置 IF = 0

### ARPL 指令
```
arpl r/m16, r16     ;调整段选择子 RPL 字段的值。一般由操作系统使用
```
该指令比较两个段选择子的 RPL 字段，目的操作数可以是包含了 16 位段选择子的通用寄存器，或者指向一个 16 位单元的内存地址，该字单元存放的是段选择子；源操作数只能是包含了段选择子的 16 位通用寄存器。
该指令执行时，处理器检查目的操作数的 RPL 字段，如果它在数值上小于源操作数的 RPL 字段，则设置 ZF 标志，并增加目的操作数 RPL 字段的值，使之和源操作数 RPL 字段的值相同。否则，ZF 标志清零，而且除此之外什么也不会发生。
arpl 是典型的操作系统指令，它通常用于调整应用程序传递给操作系统的段选择子，使其 RPL 字段的值和应用程序的特权级相匹配。

### HLT 指令
hlt 指令使处理其停止执行指令，并处于停机状态，这将降低处理器的功耗。处于停机状态的处理器可以被外部中断唤醒并恢复执行，而且会继续执行 hlt 后面的指令。

```
    hlt
```

## 八、串传送指令
这些指令对内存中的批量数据进行处理，比如，movsb、movsw、cmps、scas、lods、stos等。若要使用这些指令方便地进行批量数据的处理，则需要和 rep、repe、repne 等前缀指令配合使用。

### MOVSB 指令
在串传送指令中，控制每次操作后 si、di 的增减。若方向标志位 df = 0，则每次操作后 si、di 递增；反之 df = 1，则每次操作后 si、di 递减。

    movsb                       ; 将 ds:si 指向的内存单元中的字节送入 es:di 中，然后根据标志寄存器 df 位的值，将 si 和 di 递增或递减。
    movsw                       ; 将 ds:si 指向的内存字单元中的字送入 es:di 中，然后根据标志寄存器 df 位的值，将 si 和 di 递增 2 或递减 2。
    rep movsb                   ; rep 的作用会根据 cx 的值，重复执行后面的串传送指令。rep movsb 可实现 (cx) 个字节的传送
    rep movsw

## 中断指令
```
    int3        ;断点中断指令
    into        ;溢出中断指令
    int n       ;软中断指令，n 为中断号。
    iret        ;从中断返回，依次从栈中弹出IP、CS和标志寄存器。
```

## 九、其他指令

### CBW/CBD 指令
```
    cbw         ;无操作数，功能是将 AL 寄存器中的有符号数扩展到整个 AX
    cbd         ;无操作数，功能是将 AX 寄存器中的有符号数扩展到整个 DX:AX
```
比如：
假设原来 AL 中的内容为：01001111，执行该指令后，AX 的值为 0000000001001111；
假设原来 AL 中的内容位：10001101，执行该指令后，AX 的值为 1111111110001101
