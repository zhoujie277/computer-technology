# 中断
任何一个通用的CPU，比如8086，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息。这里所说的“中断信息”，是为了便于理解而采用的一种逻辑上的说法。它是对具有先后顺序的硬件操作所产生的事件的统一描述。

## 内中断
当CPU的内部有下面的情况发生的时候，将产生相应的中断信息：
+ 除法错误，比如，执行div指令产生的除法溢出；
+ 单步执行；
+ 执行 into 指令；
+ 执行 int 指令。

中断信息中必须包含识别来源的编码。8086CPU用称为中断类型码的数据来标识中断信息的来源。中断类型码为一个字节型数据，可以表示256种中断信息的来源。在8086CPU中的中断类型码如下：
+ 除法错误：0
+ 单步执行：1
+ 执行 into 指令： 4
+ 执行 int 指令，该指令的格式为 int n，指令中的 n 为字节型立即数，是提供给 CPU 的中断类型码。

### 中断处理程序
CPU 收到中断信息后，需要对中断信息进行处理。用来处理中断信息的程序被称为中断处理程序。一般来说，需要对不同的中断信息编写不同的处理程序。

### 中断向量表
CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表是中断向量的列表。所谓中断向量，就是中断处理程序的入口地址。展开来讲，中断向量表，就是中断处理程序入口地址的列表。在8086中，中断向量表指定放在内存地址 0 处。内存 0000:0000 ～ 0000:03FF 的 1024个单元中存放着中断向量表。在中断向量表中，一个表项存放一个中断向量，所以一个表项占两个字，高地址存放段地址，低地址存放偏移地址。

### 中断过程
当 CPU 检测到有中断信息产生时，CPU 将根据中断类型码在中断向量表中找到中断处理程序的入口，找到这个入口地址的最终目的是用它设置 CS 和 IP。使 CPU 执行中断处理程序。用中断类型码找到中断向量，并用它设置 CS 和 IP，这个工作是由 CPU 的硬件自动完成的。CPU 硬件完成这个工作的过程被称为中断过程。下面是 8086CPU 在收到中断信息后，所引发的中断过程。
1. 从中断信息中取得中断类型码；（假设类型码为N）
2. 标识寄存器的值入栈（因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中）；（pushf）
3. 设置标志寄存器的第 8 位 TF 和第 9 位 IF 的值为 0。（TF = 0，IF = 0）
4. CS 的内容入栈；（push CS）
5. IP 的内容入栈；（push IP）
6. 从内存地址为中断类型码 * 4 和中断类型码 * 4 + 2的两个字单元中读取中断处理程序的入口地址设置 CS 和 IP。（（IP）= N * 4，（CS）=（N * 4 + 2））

### 中断处理程序和 iret 指令
由于 CPU 随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。中断处理程序的编写步骤和子程序比较相似，大致如下：
1. 保存用到的寄存器；
2. 处理中断；
3. 恢复用到的寄存器；
4. 用 iret 指令返回。（iret 功能用汇编语言描述为：pop IP; pop CS; popf

### 单步中断
基本上，CPU在执行完一条指令之后，如果检测到标志寄存器的 TF 位为 1，则产生单步中断，引发中断过程。单步中断的中断类型码为 1，则它所引发的中断过程如下。
1. 取得中断类型码 1；
2. 标志寄存器入栈，TF，IF 设置为 0；
3. CS、IP入栈；
4. （IP）= 1 * 4，（CS）=（1 * 4 + 2）。

### int 指令
int 指令的格式为：int n，n 为中断类型码，它的功能是引发中断过程。

### BIOS 和 DOS 所提供的中断例程
在系统版的 ROM 中存放着一套程序，称为 BIOS，BIOS中主要包含以下几部分内容。
1. 硬件系统的检测和初始化程序；
2. 外部中断和内部中断的中断例程
3. 用于对硬件设备进行 I/O 操作的中断例程；
4. 其他和硬件系统相关的中断例程。

### BIOS 和 DOS 中断例程的安装过程
1. 开机后，CPU 一加电，初始化（CS）= 0FFFFH，（IP）= 0，自动从 FFFF:0 单元开始执行程序。FFFF:0 处有一条转跳指令，CPU执行该指令后，转去执行 BIOS 中的硬件系统检测和初始化程序。
2. 初始化程序将建立 BIOS 所支持的中断向量，即将 BIOS 提供的中断例程的入口地址登记在中断向量表中。注意，对于 BIOS 所提供的中断例程，只需将入口地址登记在中断向量表即可，因为它们是固化到 ROM 中的程序，一直在内存中存在。
3. 硬件系统检测和初始化完成后，调用 int 19h 进行操作系统的引导。从此将计算机交由操作系统控制。
4. DOS 启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。

## 端口
在计算机中，各种存储器都和 CPU 的地址线、数据线、控制线相连。CPU 在操控它们的时候，把它们都当作内存在对待，把它们总地看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器我们称其为内存地址空间。在PC机系统中，和 CPU 通过总线相连的芯片除各种存储器外，还有以下 3 种芯片：
+ 各种接口卡（比如，网卡、显卡）上的接口芯片，它们控制接口卡进行工作；
+ 主板上的接口芯片，CPU 通过它们对部分外设进行访问；
+ 其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。

在这些芯片中，都有一组可以由 CPU 读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，但是它们在以下两点上相同。
+ 都和 CPU 的总线相连，当然这种连接是通过它们所在的芯片上进行的；
+ CPU 对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。

可见，从 CPU 的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。CPU 可以直接读写以下 3 个地方的数据。
+ CPU内部的寄存器
+ 内存单元
+ 端口

### 端口的读写
在访问端口的时候，CPU 通过端口地址来定位端口。因为端口所在的芯片和 CPU 通过总线相连，所以，端口地址和内存地址一样，通过地址总线来传送。对端口的读写不能用 mov、push、pop等内存读写指令。端口的读写只有两条：in 和 out，分别用于从端口读取数据和往端口写入数据。比如：

    in al, 60h      ;表示从 60h 号端口读入一个字节
    上述代码执行时与总线相关的操作如下：
    1. CPU 通过地址线将地址信息 60h 发出；
    2. CPU 通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；
    3. 端口所在的芯片将 60h 端口中的数据通过数据线送入 CPU。
    4. 注意，在 in 或 out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据火药发送到端口中的数据。访问 8 位端口用 al，访问 16 位端口用 ax。
   
## 外中断
有一种中断信息，来自于 CPU 外部，当 CPU 外部有需要处理的事情发生的时候，比如说，外设的输入到达，相关芯片将向 CPU 发出相应的中断信息。 CPU 在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。在 PC 系统中，外中断源一共有以下两类。
+ 可屏蔽中断；可屏蔽中断是 CPU 可以不响应的外中断。CPU 是否响应可屏蔽中断，要看标志寄存器的 IF 位的设置。如果 IF = 1，响应中断；否则 IF = 0，不响应可屏蔽中断。
+ 不可屏蔽中断。对于 8086CPU ，不可屏蔽中断的中断类型码固定为 2。