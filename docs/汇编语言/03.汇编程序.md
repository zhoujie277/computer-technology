# 汇编程序
用汇编语言写的源程序，包括伪指令和汇编指令。我们编程的最终目的是让计算机完成一定的任务。源程序的汇编指令组成了最终由计算机执行的程序，而源程序中的伪指令是由编译器来处理的。

## 源程序
源程序基本结构
1. 伪指令: 伪指令是由编译器来执行的指令，编译器根据伪指令进行相关的编译工作。
2. 源程序中的“程序”
3. 标号
4. 程序返回

### 一个源程序从写出到执行的过程
1. 编写汇编源程序。
2. 对源程序进行编译连接。最终编译成可在操作系统直接运行的可执行文件，可执行文件包含两部分内容：
   1. 程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
   2. 相关的描述信息（比如，程序有多大，要占用多少内存空间等）。操作系统可根据可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的额初始化（比如设置CS：IP指向第一条要执行的指令），然后由CPU执行程序。描述信息主要是编译、连接程序对源程序中相关伪指令进行处理所得到的信息。
3. 执行可执行文件中的程序。

## [BX] 和 loop 指令

### [bx]和内存单元的描述

要完整的描述一个内存单元，需要两种信息：
+ 内存单元的地址；
+ 内存单元的长度（类型）

用[bx]表示一个内存单元时，bx 表示单元的偏移地址，段地址默认在 DS 中，单元的长度可以由具体指令中的其他操作对象（比如寄存器）指出。例如:

    mov ax, [bx]
    功能：bx中存放的数据作为一个偏移地址 EA，段地址 SA 默认在 DS 中，将 SA : EA 处的数据送入ax中。

### Loop指令
loop指令的格式是：
    loop 标号
    
CPU执行 loop 指令的时候，要进行两步操作：
1. (cx) = (cx) - 1;
2. 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。

## 包含多个段的程序
程序去的所需空间的方法有两种：
1. 在加载程序的时候为程序分配
2. 程序在执行的过程中向系统申请。

## 数据处理的两个基本问题

### 机器指令处理的数据在什么地方
1. 立即数：直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中）
2. 寄存器：指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名
3. 段地址（SA）和偏移地址（EA）

### 寻址方式
+ 直接寻址：[idata]
+ 寄存器间接寻址：[bx]
+ 寄存器相对寻址：[bx + idata]
+ 基址变址寻址：[bx + si]
+ 相对基址变址寻址：[bx + idata + si]

### 指令要处理的数据有多长
8086CPU中，可以处理两种尺寸的数据，byte和word。在机器指令中要指明，指令进行的是字操作还是字节操作。
+ 通过寄存器指明要处理的数据的尺寸
+ 在没有寄存器名存在的情况下哎，用操作符 x ptr 指明内存单元的长度，x 在汇编指令中可以为 word 和 byte。例如
```
mov word ptr ds:[0], 1
mov byte ptr ds:[0], 1
```

## 转移指令的原理
可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令。8086CPU的转移行为有以下几类。
+ 只修改IP时，成为段内转移，比如 jmp ax。
+ 同时修改 CS 和 IP 时，成为段间转移，比如 jmp 1000:0。

转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。
+ 短转移 IP 的修改范围为 -128 ～ 127.
+ 近转移 IP 的修改范围为 -32768 ～ 32767
  
8086CPU的转移指令分为以下几类
+ 无条件转移指令（如：jmp）
+ 条件转移指令
+ 循环指令（如：loop）
+ 过程
+ 中断

### 操作符 offset
操作符offset是汇编语言中由编译器处理的符号，它的功能是取得标号的偏移地址。


## Call 和 Ret 指令
call 和 ret 都是转移指令，它们都修改IP，或同时修改 CS 和 IP。它们经常被共同用来实现子程序的设计。

+ ret 指令用栈中的数据，修改 IP 的内容，从而实现近转移；
+ retf 指令用栈中的数据，修改 CS 和 IP 的内容，从而实现远转移。
+ CPU 执行 call 指令时，进行两步操作：
  + 将当前的 IP 或 CS 和 IP 压入栈中；
  + 转移。
+ call指令不能实现短转移，除此之外，call指令实现转移的方法和 jmp 指令的原理相同。

## 标志寄存器
CPU内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）具有以下3种作用。
1. 用来存储相关指令的某些执行结果；
2. 用来为CPU执行相关指令提供行为依据；
3. 用来控制CPU的相关工作方式。

这种特殊的寄存器在8086CPU中，被称为标志寄存器。8086的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW）。

### 标志位
+ ZF标志：flag的第 6 位是 ZF，零标志位。它记录相关指令执行后，其结果是否为0.如果为0，zf = 1；否则，zf = 0。
+ PF标志：flag的第 2 位是 PF，奇偶标志位。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。如果为偶数，pf = 1；否则， pf = 0；
+ SF标志：flag的第 7 位是 SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果为负数，sf = 1；否则，sf = 0。
+ CF标志：flag的第 0 位是 CF，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。
+ OF标志：flag的第 11 位是 OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF = 1；否则，OF = 0。
+ DF标志：flag的第 10 位是 DF，方向标志位。在串传送指令中，控制每次操作后 si、di 的增减。若df = 0，每次操作后，si、di递增；若df = 1，每次操作后，si、di递减。

### cmp 指令
cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志位产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。常见的相关指令有：

|  指令   | 含义         |  检测的相关标志位 | 指令英文全称
|  ----  | -----------  | ------ | ----------
|  je    | 等于则转移    | zf = 1  | jmp equal
|  jne   | 不等于则转移   | zf = 0 | jmp not equal
|  jb    | 低于则转移    | cf = 1  | jmp below
|  jnb   | 不低于则转移   | cf = 0 | jmp not below
|  ja    | 高于则转移    | cf = 0 且 zf = 0 | jmp above
|  jna   | 不高于则转移   | cf = 1 且 zf = 1| jmp not above


## 直接定址表
先看一段代码
```
  assume cs:code
  code segment
    a db 1,2,3,4,5,6,7,8        ;此处定义a没有冒号:
    b dw,0
    
  start: mov si, 0
         mov cx, 8
      s: mov al, a[si]          ;使用 a 和索引寄存器 si 访问 a 数据段中的的数据
         mov ah, 0
         add b, ax
         inc si
         loop s
         mov ax, 4c00h
         int 21h
  code ends
  end start
```

可以看到，在 code 段中使用的标号 a、b 后面没有用 “:",它们是同时描述内存地址和单元长度的标号。标号 a，描述了地址 code:0，和从这个地址开始，以后的内存单元都是字节单元；而标号 b 描述了地址 code:8, 和从这个地址开始，以后的内存单元都是字单元。我们将这种标号称为数据标号，它不同于仅仅表示地址的地址标号，它标记了存储数据的单元的地址和长度。<br/>
地址标号只能在代码段中使用，而数据标号可以任何段中使用来描述存储数据的单元的地址和长度。