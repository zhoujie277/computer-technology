
### 线程池相关 FAQ

> 在多线程编程中，软件开发者常用一种“三级模式”，即处理器 - 调度器(线程) - 任务 三级模式。其中调度器通常是线程池，将任务的提交过程和执行过程分离开来，更好的进行资源管理。

#### 为什么需要线程池这种组件？
1. 将任务的提交过程和执行策略解耦分离，使得修改执行策略不会影响到提交过程。
2. 进行有效的资源管理，防止无限制的线程增长。线程无限制的增长缺陷主要有
   1. 线程生命周期的开销非常高。线程的创建和销毁需要消耗资源，当无限制的为每个请求都创建一个新线程将消耗大量的计算资源。
   2. 资源消耗。活跃的线程会消耗系统资源，特别是内存。如果可运行的线程数量多余可用处理器的数量，那么有些线程会闲置。大量空闲的线程会占用许多内存。
   3. 稳定性。在大多数平台上，可创建的线程数量均存在一个限制。如果破坏了这些限制，将会引发 OutOfMemoryError 异常。

#### 能不能所有的任务都使用一个线程池，或者除了 UI 任务外，其他任务都使用同一个线程池？使用线程池有什么建议和规范?
1. 第一个问题和第二个问题属于同一个问题，答案是不要这么做。
2. 第三个问题问的是对前面两个问题的答案的解释。在实际中，只有当任务都是同类型的并且相互独立的，才建议使用同一个线程池，此时，线程池的性能才能达到最佳。如果将运行时间较长的任务和时间较短的任务混合在一起，那么除非线程池很大，否则将可能造成某些任务饥饿的问题发生。即某些线程一直在忙着导致另一些任务得不到执行而拥塞。另外，如果提交的任务依赖于其他任务，除非线程池无限大，否则有可能发生阻塞。总而言之，区分任务的类型以及根据其需要使用不同的执行策略。

#### 线程池大小设置多少合适？设置不合适有什么后果？
+ 一般需要分析其计算环境、资源预算和任务的特性。比如机器的处理器个数、以及任务的类型（任务的等待时间和计算时间之比）、期望的 CPU 利用率、等条件来设置线程池大小。假设机器处理器核心数为 N，期望 CPU 利用率为 U, 任务等待时间为 W，计算时间为 C。
  + 如果是计算密集型任务，线程池大小一般分配为 N + 1 比较合适。多一个线程是为了防止缺页故障或其他错误导致线程暂停，这个额外的线程可以充分地提高资源利用率。
  + 如果是 I/O 密集型或者其他阻塞操作的任务，一般会需要比较大的线程池，因为其线程并不会一直执行。比如 Executors.newCachedThreadPool().
   推荐线程池大小计算公式为：
   ```
      N(thread) = N(CPU) * U * (1 + W/C )
   ```

   这个公式告诉我们，如果我们期望 CPU 的利用率越高，任务的阻塞性越强（即依赖 CPU 越弱），则需要分配的线程池就要尽可能的大。

   另外，除了纯考虑任务本身之外，在实践中，能分配的最大线程数往往还需要受限于内存、资源池的大小、文件句柄、套接字句柄和数据库连接等。

+ 如果线程池设计过大，则可能引起大量线程在相对较少的 CPU 或者内存资源上发生竞争。不仅会导致更高的内存使用量，还可能耗尽资源。如果线程池过小，则可能导致许多的空闲的处理器，浪费了资源，从而降低了系统吞吐量。

#### Java 线程池有哪些参数可以配置？
核心线程数大小、最大线程数大小、饱和策略、阻塞队列类型、线程工厂。

#### Java 线程池中，提供了哪几种饱和策略？
+ 中止策略（Abort) 是默认的饱和策略。该策略将抛出未检查的 RejectedExecutionException。调用者可以捕获这个异常，然后自己处理。
+ 抛弃策略（Dicard）。将会悄悄的抛弃该任务。
+ 抛弃最旧策略（Discard-Oldest）。将会抛弃下一个将被执行的任务，然后尝试重新提交新的任务。
+ 调用者运行策略（Caller-Runs）。该策略实现了一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将任务回退到调用者，从而降低新任务的流量。

#### ThreadPoolExecutor 中工作线程是不是空闲的？
+ Worker 实现了 AbstractQueuedSynchronizer。在获取到任务，准备执行之前，先获取锁，任务执行完成，准备获取下一个任务之前，释放锁。例如在 interruptIdleWorkers() 方法中需要中断空闲线程，该方法内部会通过 tryLock 尝试获取锁，获取到了，则是空闲线程，反之则是忙线程。另外，当 shutdown 调用时，先 trylock 到了，便认为它是空闲线程，于是 interrupt()，但是，如果此时 worker 已经有获得任务且已经在 lock 等待了，待它获得锁后，会清除中断标记。

#### 在使用线程池的 web 服务中，如何实现限流？以及性能的优雅降级？
1. 饱和策略可以使用调用者执行策略。由于调用者执行任务需要一定的时间，因此主线程至少在一段时间内不能提交新任务，从而使得工作者线程有时间来处理完正在执行的任务。在这期间，主线程不会接收新的 web 请求，因为到达的请求将被保存在 TCP 层的队列中而不是在应用程序的队列中。如果持续过载，那么 TCP 层将最终发现它的请求队列被填满，因此同样会开始抛弃请求。当服务器过载时，这种过载情况会逐渐向外蔓延开来。也就是说从线程池到工作队列到应用程序再到 TCP 层，最终到达客户端，使得服务器在高负载下实现一种平缓的性能降低。

#### ExecutorService 的 shutdown() 和 shutdownNow() 有什么区别？
+ shutdown() 是平缓的关闭，它会取消空闲的工作线程并且阻止任务再提交。但会让已经提交的任务继续进行。
+ shutdownNow() 则会立即关闭。它会取消所有工作线程并且中断当前正在执行任务的线程，如果正在运行的任务响应中断，那么它会被终止，并且随后线程也会被终止。另外，shutdonwNow() 还会返回所有已经提交但尚未开始的任务。值得注意的是，如果不做特殊处理，那么 shutdownNow() 是无法知道哪些是已经开始运行但尚未执行完成的任务。（除非任务自己执行某种检查）

#### 程序设计中，任务需要被取消可能会有哪些原因？
1. 用户请求取消。例如用户点击 GUI 提供的“取消”按钮。
2. 有时间限制的操作。例如某个应用程序需要在有限时间内搜索问题空间，并在这个时间内选择最佳的解决方案。当计时器超时时，需要取消所有正在搜索的任务。
3. 应用程序事件。例如，应用程序对某个问题空间进行分解并搜索，从而使不同的任务可以搜索问题空间中的不同区域。当其中一个任务找到了解决方案时，所有其他仍在搜索的任务都将被取消。
4. 错误。比如应用程序执行某任务发生错误时（比如磁盘空间已满），那么可能需要取消任务。
5. 关闭。当应用程序关闭时，必须对正在处理和等待处理的工作执行某种操作。在平缓的关闭过程中，当前正在执行的任务将继续执行直到完成，而在立即关闭过程中，当前任务则可能取消。

#### 在 Java 中，延迟任务和周期任务的实现方式有哪些？它们各自的特点是？在使用建议上有什么区别？
延迟任务和周期任务的实现方式主要有 Timer 和 ScheduledThreadPoolExecutor。

Timer 的特点是。
1. 所有任务均通过小顶堆无界优先队列排队，一个线程 TimerThread 轮询优先队列，将其最靠前的任务（即绝对值时间最近的任务）先执行。所有任务在 TimerThread 均是串行执行。
2. 如果 TimerTask 抛出了一个未检查的异常，TimerThread 将会终止，并且不会恢复运行。此种情况下，已经被调度但尚未执行的 TimerTask 将都不会被执行。新的任务也不能被调度。

ScheduledThreadPoolExecutor 的特点是。
1. 其任务队列依然采用了小顶堆的无界优先队列，但是其可以指定 corePoolSize 大小来指定多线程的执行方式，即一个 Task 的运行可以不影响到另一个任务的运行。
2. 由于继承自 ThreadPoolExecutor，其一个任务的异常终止不会影响到其他任务的执行。

#### CompletionService 有什么作用？
CompletionService 提供了管理一组 FutureTask 的接口，具体实现参考 ExecutorCompletionService，其提供了提交任务的代理 Executor，以及使得一组 FutureTask 可并行执行，先得到结果的 Task 存放至一个 BlockingQueue，调用者可通过 take() 方法等待获取先返回来的任务。

#### DelayQueue 为什么要采用 leader/follow 模式？ 
