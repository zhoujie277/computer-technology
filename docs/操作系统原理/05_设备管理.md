## 设备管理

### I/O 管理概述

#### I/O 管理的功能

##### I/O 管理的目标
+ 选择、分配及控制 I/O 设备，以便能进行数据传输工作
+ 为用户提供一个统一友好的接口。
+ I/O 管理软件的层次结构。
+ 高效率。除了合理分配各种 I/O 设备外，还要尽量提高设备与CPU、设备与设备之间的并行程度。

##### I/O 管理的主要功能
1. 监视设备的状态。I/O 管理的功能之一就是记住所有设备、控制器和通道的状态，以便有效地管理、调度和使用它们。
2. 进行设备分配。按照设备的类型和系统所采用的的分配算法，实施设备分配，并把未分配到所请求设备、控制器和通道的进程投入等待队列。
3. 完成 I/O 操作，尽量实现设备与CPU、设备与设备之间的并行。
4. 缓冲管理。为了解决设备与CPU速度不匹配的问题，系统中一般都设有缓冲区来管理数据。设备管理程序还要负责缓冲区的分配、释放及有关的管理工作。

#### I/O 硬件组成
##### 微机 I/O 系统
如果计算机中一个或多个设备使用一组共同的先，那么这种连接成为总线结构。总线时一组线和一组严格定义的可以描述线上传输信息的协议。微机 I/O 系统多采用总线结构。PCI（Peripheral Component Interconnect）总线用于连接处理器、内存及快速设备。扩展总线用于连接串行、并行端口及相对较慢的设备。CPU 通过设备控制器与 I/O 设备进行通信，并控制相应的设备。
##### 主机 I/O 系统
主机 I/O 系统不采用总线结构，而是增加一级 I/O 通道，用以代替主机与各个设备控制器进行通信，并实现对它们的控制。

#### I/O 设备
##### 设备的类型
按设备进行信息交换的单位，I/O 设备可分为块设备和字符设备。
+ 块设备。块设备也称为存储设备，是计算机中用来存储信息的主要设备。由于块设备对信息的存取总是以数据块为单位，故称为块设备。
+ 字符设备。字符设备也称为 I/O 设备，用于数据的输入和输出。由于 I/O 设备上的信息是以字符为单位组织的，故称为字符设备。

##### 设备之间的差异
设备的以下差异使得无论从操作系统的角度，还是从用户进程的角度，都很难实现一种统一、一致的 I/O 方法。
+ 数据传输速率。
+ 管理程序不同。
+ 控制的复杂度不同。
+ 数据的传送单位不同
+ 数据编码不同。
+ 出错条件不同。

##### 设备标识
一个计算机系统中可以配置多种类型的设备，并按某一原则为每台设备分配一个唯一的号码，用于区分硬件和识别设备，这个唯一的号码称为绝对设备号。为了使用方便，操作系统为每类设备规定一个编号，称为设备类型号。用户程序使用系统规定的设备类型号一级用户自己规定的相对设备号向操作系统提出设备申请，操作系统将其抓换成系统中的绝对设备号为其分配设备。

#### 设备控制器
I/O 设备一般由机械和电子两部分组成。机械部分就是设备本身，电子部分称为设备控制器或设备器。设备控制器用于管理端口、总线或设备，实现设备主体（机械部分）与主机之间的连接与通信。

##### 设备控制器的组成
+ 设备控制器与CPU的接口。用于CPU与设备控制器之间的通信，共有 3 类信号线，分别为数据线，地址线和控制线。每个控制器通常由几个寄存器用于与CPU进行通信，这些寄存器分成数据寄存器和控制/状态寄存器。操作系统将命令写入控制器的控制/状态寄存器中，以实现 I/O操作。当CPU需要与设备进行数据传输时，数据寄存器用于暂存设备的数据。
+ 设备控制器与设备的接口。设备控制器与设备的接口有多个，每个设备使用一个接口。控制器与设备之间的接口通常是一个很低层的接口，每个接口中存有数据、控制和状态 3 种类型的信号。控制器中的 I/O 逻辑根据 CPU 发来的地址信号选择一个设备接口。
+ I/O 逻辑。用于实现对设备的控制。它通过一组控制线与 CPU 交互，CPU 通过该逻辑向控制器发送命令；I/O 逻辑对收到的命令进行译码。

##### 设备控制器的任务
1. 接收和识别命令。CPU可以向控制器发送多种命令，设备控制器为了接受和识别这些明亮，在控制器中有相应的控制寄存器，用来存放接收的命令和参数，并对接收的命令进行译码。
2. 数据交换。为了实现 CPU 与控制器、控制器与设备之间的数据交换，控制器中设置了数据寄存器。CPU 通过数据线将数据写入控制器的数据寄存器，或从控制器中读出；而设备将数据输入控制器的数据寄存器，或从控制器读出数据。
3. 了解设备的状态。控制器要记下设备的状态供 CPU 了解。例如当设备就绪时，CPU 才能启动控制器从设备中读出数据。
4. 地址识别。系统中的每一个设备都有一个地址，而设备控制器必须能够识别它所控制的每个设备的地址。此外，为了使 CPU 能从控制器的寄存器中读出数据，这些寄存器也应具有唯一的地址。

#### 设备通道
虽然在 CPU 与设备之间增加了设备控制器，已能大大减少 CPU 的干预，但当计算机配置的外设很多时，CPU 的负担仍然很重。为此，在许多计算机系统中配置了通道，其目的就是建立独立的 I/O 操作，使 CPU 从繁重的 I/O 中解放出来。
通道实际上是一个特殊的处理机，它具有执行 I/O 指令的能力，并通过执行通道程序来控制 I/O 操作。但通道又与一般的处理机有所不同，主要表现在以下两个方面。
+ 通道指令类型单一。由于通道硬件比较简单，其所执行的指令局限于与I/O操作有关的指令。
+ 通道内没有自己的内存。通道执行的指令一般放在其主机的内存中。

##### 通道的类型
通道是用于控制外部设备的，由于外设的类型较多，且其传输速率相差悬殊。因而使得通道具有多种类型。
+ 字节多路通道。主要用于连接低速的字符设备，每次传送的信息以字节为单位。
+ 数组选择通道。用于连接高速的块设备，以块为数据传输单位。
+ 数组多路通道。既具有很高的数据传输速率，又能获得令人满意的通道利用率。

### I/O 控制方式
设备管理的任务之一就是控制设备，在设备与内存之间传送数据，选择和衡量数据传送控制方式的原则有如下几条。
+ 数据传送速度足够高，能满足用户的需要而又不丢失数据。
+ 系统开销小，需要的处理控制程序少。
+ 能充分发挥硬件资源的能力，使得 I/O 设备尽可能忙，CPU 等待时间尽量少。

随着计算机系统的发展，计算机单个部件的复杂度和完善性页随之增加，I/O 功能更是如此。I/O 功能的发展可概括如下。
+ CPU 直接控制外设，这在早期的计算机系统和微处理控制设备中比较常见。
+ 有了控制器和 I/O 模块，但 CPU 使用没有中断的程序控制 I/O。
+ 采用中断控制方式，CPU 不再花费时间等待执行下一个 I/O 操作，因而效率得到了提高。
+ 采用DMA控制方式，可以在没有 CPU 参与的情况下从内存读出或向内存写入一块数据，仅仅在传输开始和结束时需要 CPU 的干预。
+ 采用通道控制方式，通道是一个单独的处理机，它有专门的 I/O 指令集。CPU 指示通道执行内存中一个 I/O 程序，通道在没有 CPU 干涉的情况下取指令并执行指令。
+ 通道有了自己的局部存储器，它本身就是一个计算机。它可以控制许多 I/O 设备，并且使需要主机参与的部分最小。这种结构通常用于控制与终端的交互和通信。

从以上的发展过程中可以看出，越来越多的 I/O 都可以在没有主机控制的情况下进行。CPU 从 I/O 任务中解脱出来，从而提高了性能。

#### 程序直接控制方式
程序直接控制方式就是由用户进程直接控制 CPU 与外设之间的信息传送。这种方式存在以下缺点。使得它只适用于那些 CPU 执行速度较慢且外设较少的系统。
+ CPU 与外设之间只能串行工作。由于 CPU 的处理速度远远高于外设的数据传送速度，所以 CPU 在大量的时间内都处于等待和空闲状态。这使得 CPU 的利用率大大降低。
+ CPU 在一段时间内只能与一台外设交换数据信息，因此多台外设之间也是串行工作。
+ 由于程序直接控制方式是依靠测试设备的状态来控制数据的传送，因此无法发现和处理由于设备和其他硬件所产生的错误。

#### 中断控制方式
为了减少程序直接控制方式中 CPU 的等待时间，提高系统并行工作的程度，现代计算机系统中广泛采用了中断控制方式。这种方式要求 CPU 与设备控制器之间有相应的中断请求线，设备控制器的控制/状态寄存器中有相应的中断允许位。数据的输入过程如下：
1. 进程运行过程中，当需要输入数据时，通过 CPU 发出指令启动外设，同时该指令还将控制/状态寄存器的中断位置为”允许“，以便在需要时，中断处理程序可以被调度执行。
2. 在进程发出启动指令后，该进程放弃处理机，等待输入完成，从而使进程调度程序可以调用其他进程执行。
3. 当输入完成时，设备控制器通过中断请求线向 CPU 发出中断信号。CPU 在接收到中断信号后，转向执行中断处理程序，对数据传送进行相应处理。
4. 当进程调度程序选中发出启动指令的进程时，该进程从内存指定单元取出需要的数据继续工作。

与程序直接控制方式相比，中断控制方式可以成百倍地提高 CPU 的利用率，但还存在如下一些问题。
+ 设备控制器的数据寄存器装满数据后发生中断。数据寄存器通常只能存放一字节的数据，因此在进程传送数据的过程中，发生中断的次数可能很多，这将消耗CPU的大量处理时间。
+ 计算机中通常配置各种各样的外设，如果这些外设都通过中断的方式进行数据传送，则会由于中断次数的急剧增加造成 CPU 无法及时响应中断，出现数据丢失现象。
  
#### DMA 控制方式

##### DMA 控制器
DMA 也是有3个部分组成的，即主机与 DMA 控制器之间的接口、I/O 控制逻辑和 DMA 控制器与设备之间的接口。在 DMA 控制器中，设置了 4 类寄存器。
1. 控制/状态寄存器用于接收从 CPU 发来的 I/O 命令或有关控制信息，或 CPU 用于了解设备的状态。
2. 数据寄存器用于暂存从内存到设备或从设备到内存的数据。
3. 内存地址寄存器，用于存放数据从设备传送到内存的目标地址，或从内存到设备时内存的源地址。
4. 数据计数器存放本次 CPU 要读或写数据的字节数。

##### 处理过程
由于在 DMA 控制器中增加了内存地址寄存器和数据计数器，DMA 控制器可以代替 CPU 控制内存与设备之间进行成块的数据交换。成块数据的传送由数据计数器进行计数，由内存地址寄存器确定内存的地址。除了在数据块的传送开始时需要 CPU 发出启动指令，以及在整块数据传送完毕时需要发中断通知 CPU 进行中断处理之外，DMA 方式不像中断控制方式那样需要 CPU 的频繁干预。DMA 控制方式的数据输入过程如下。
1. 当进程要求设备输入数据时，CPU 把准备存放数据的内存起始地址以及要传送数据的字节数分别送入 DMA 控制器的内存地址寄存器和数据计数器，并把控制/状态寄存器中的中断位置为”允许“，忙/闲标志位置为 0，从而启动设备开始进行数据输入。
2. 发出数据传送请求的进程进入等待状态，进程调度程序调度其他进程占用 CPU 执行。
3. 输入设备不断地挪用 CPU 工作周期，将数据寄存器中的数据源源不断的写入内存，直到所要求的的字节数全部传送完毕。
4. DMA 控制器在传送字节数完成时，通过中断请求线发中断信号，CPU 在接到中断信号后，转中断处理程序进行善后处理。
5. 中断处理结束时，CPU 返回被中断进程处继续执行。

##### 特点
1. 数据传输的基本单位是块，即 CPU 与 I/O 设备之间每次传送一个数据块的数据。
2. 所传送的数据时从设备直接到内存或者从内存直接到设备。
3. 仅在传送数据块的开始和结束时需要 CPU 的干预，整块数据的传送是在控制器的控制之下完成的。

DMA 方式仍存在着一定局限性。
+ DMA 方式对外设的管理和操作仍有 CPU 控制。
+ 多个 DMA 同时使用显然会引起内存地址的冲突并使得控制过程进一步复杂化。
+ DMA 仍然会占用一定的访存周期。
+ 如果需要一次读写多个离散的数据块，且将它们送到内存的不同区域，则需要由 CPU 分别发出多条 I/O 指令及进行多次中断处理才能完成。

#### 通道控制方式
通道控制方式是 DMA 控制方式的发展，它可以进一步减少 CPU 的干预，即把对一个数据块的读写干预减少到对一组数据块的读写干预；同时又可实现 CPU、通道及 I/O 设备三者之间的并行工作，从而更有效地提高整个系统的资源利用率。

##### 通道指令
通道通过通道处理程序，与设备控制器共同实现对 I/O 设备的控制。通道处理程序是由一系列通道指令构成的。通道指令在进程要求传送数据时自动生成。通道指令的格式一般由操作码、计数、内存地址和结束位构成。
1. 操作码规定了指令所要执行的操作，如读、写、控制等。
2. 计数表示本条指令要读写数据的字节数。
3. 内存地址标识数据要送入的内存地址或从内存的何处取出数据。
4. 通道程序结束位 P 表示通道程序是否结束。P = 1 表示本条指令是通道程序的最后一条指令。
5. 记录结束位 R=0，表示本条通道指令与下一条通道指令所处理的数据数一个记录；R=1，表示该指令处理的数据是最后一条记录。

##### 通道控制方式处理过程
1. 当进程要求设备输入数据时，CPU 发出启动指令，并指明要进行的 I/O 操作、使用的设备的设备号和对应的通道。
2. 通道接收到 CPU 发来的启动指令后，把存放在内存的通道处理程序取出，开始执行通道指令。
3. 执行一条通道指令，设置对应设备控制器的控制/状态寄存器。
4. 设备根据通道指令的要求把数据送往内存指定区域。如果本指令不是通道处理程序的最后一条指令，取下一条通道指令，并转（3）继续执行；否则执行（5）。
5. 通道处理程序执行结束，通道向 CPU 发中断信号请求 CPU 做中断处理。
6. CPU 接到中断处理信号后进行善后处理，然后返回被中断进程处继续执行。

### 磁盘管理

#### 磁盘结构和管理
+ 磁头(Header)：一个磁盘中包含多个盘片，每个盘片分两面，每面有一个读写磁头。
+ 柱面(Cylinder)：每个盘面上存储介质同心圆环称为磁道，刺刀之间留有必要的缝隙。通常，最外层的磁道为 0 号，向内磁道号逐步增加。柱面是指硬盘的多个盘面的同一磁道组成的面。
+ 扇区(Sector)：扇区是将磁道按照相同角度等分的扇形，每个磁道上的等分段都是一个扇区。

当向磁盘寻址时，一般表示为柱面（磁道）号、磁头（盘面）号、扇区号。在进行数据读写时，通过磁头从磁盘中取出、存入数据。磁头是固定不动的，磁盘在其下面旋转。

#### 磁盘的格式化
磁盘的格式化分为两个层次。
+ 低级格式化：其任务是按照规定的格式为每个扇区填充格式控制信息。一般在厂商出厂之前完成。
+ 高级格式化：其任务是在磁盘上建立文件系统。由用户利用操作系统提供的工具完成。

#### 磁盘调度
由于在磁盘上产生性能差异的原因主要是寻道时间。如果扇区访问请求包括随机选择磁道，磁盘 I/O 的速度会非常低，为了提高性能，需要选择一种合适的磁盘调度算法。常见的磁盘调度算法如下。

##### 先来先服务（First Come First Served, FCFS)
最简单的磁盘调度算法就是FCFS，它根据进程请求访问磁盘的先后顺序进行调度。此算法的优点是公平、简单，且每个进程的请求都一次得到处理，不会出现某一进程的请求长期得不到处理的情况。但此算法由于没有对寻道进行优化，致使平均寻道时间较长。

##### 最短寻道时间优先（Shortest Seek Time First，SSTF）
该算法尽可能使寻道距离最短，即总是选择要求访问的磁道与磁头所在的磁道的距离最近的进程。该算法能得到较优的平均寻道时间，但是它有可能导致某些进程出现”饥饿“现象。因为如果不断有新进程到达，且其所要访问的磁道与磁头当前所在的磁道的距离较近，这种新进程的 I/O 请求必然先被满足，而那些老进程的 I/O 请求就有可能永远得不到满足。

##### 扫描算法（SCAN）
该算法不仅考虑要访问的磁道与当前磁头所在磁道的距离，更优先考虑的是磁头的当前移动方向。比如刚开始从磁道号100的地方从沿磁道号增大的方向（从外向里）进行访问，直到最再无更大的磁道需要访问时，才将磁臂换向，从里向外移动。移动过程中，同样也是每次选择了距离当前磁道最近的进程所在的磁道进行访问，由于该算法磁头的移动规律很像电梯的运行，故又称为电梯调度算法。这种算法即获得了较好的寻道性能，又能防止进程饥饿现象的发生，故被广泛采用。

##### 循环扫描算法（Circular SCAN，C-SCAN)
扫描算法依然存在一个问题：当磁头刚从里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时，该进程必须等待，待磁头从里向外，然后再从外向里扫描完所有的磁道后才处理该进程的请求，致使该进程的请求被严重推迟。为了减少这种延迟。C-SCAN算法规定磁头单向移动。磁头从里向外移动，当磁头移动到最外被访问的磁道时，磁头立即返回到最里的要访问的磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。

##### N-Step-SCAN 算法
对于 SSTF、SCAN 和 C-SCAN，都可能出现磁臂停留在某处不动的情况。例如，如果一个或多个进程对某一磁道有较高的访问频率，即反复地请求对某一磁道进行 I/O，从而垄断了整个设备，这一现象称为”磁臂黏着“。高密度磁盘上更容易出现此情况。N-Step-SCAN 算法将磁盘请求队列分成若干个长度是 N 的子队列，磁盘调度将按 FCFS 算法依此处理这些子队列。而处理每一个队列时，又是按 SCAN 算法，一个队列处理完毕后，再处理另一个队列，这样就可以避免出现黏着现象。当 N 值很大时，N-Step-SCAN算法的性能接近于 SCAN 算法；当 N=1 时，N-Step-SCAN 算法就退化为 FCFS 算法。

##### FCSAN 算法
FSCAN算法本质上是 N-Step-SCAN 算法的简化，它直降磁盘请求访问队列分成两个子队列。一个子队列是当前所有请求磁盘 I/O 的进程形成的队列，由磁盘调度算法 SCAN 进行处理。另一个子队列则是在扫描期间新出现的所有请求磁盘 I/O 进程所形成的的队列，所有心情求都被推迟到下一次扫描时处理。

### 缓冲管理
在操作系统中引入缓冲的目的，可以归结为以下几点：
1. 缓解 CPU 与 I/O 设备之间速度不匹配的矛盾。
2. 减少中断 CPU 的次数。
3. 提高 CPU 与 I/O 设备之间的并行性。

#### 缓冲
缓冲是一种被泛采用的计数，广义来说，缓冲是在通信问题中，为了通信双方的速度匹配而引入的一个中间层次，这个层次的速度比通信双方中较慢的一方块，而与较快的一方更匹配。按照这个定义，就其设置可分成以下4种。
1. Cache。
2. I/O 设备或控制器内部的纯硬件缓冲区。
3. 内存开辟的缓冲区。操作系统在内存中开辟的 I/O 设备缓冲区、文件缓冲区。
4. 脱机 I/O 技术和 SPOOLing技术也属于缓冲技术。实际上是为慢速 I/O 设备在外存储器上开设的缓冲区。

##### 单缓冲
单缓冲是当用户发出 I/O 请求时，操作系统在主存中为其分配一缓冲区，当块设备使用单缓冲时，要读取磁盘上的某块数据。首先从磁盘把数据送入内存缓冲区，其所花费的时间为 T；然后由操作系统将缓冲区的数据送入用户区，花费的时间为 M；接着 CPU 对数据进行处理，其所花费的时间为 C；则系统对整块数据的处理时间为 max(C,T) + M。（通常 M 远小于 C 和 T）。
如果不使用缓冲区，数据直接送入用户区，则一块数据的处理时间为 T + C。因此使用缓冲技术可以提高处理 I/O 请求的速度。
使用单缓冲技术，必须保证设备的速度与CPU的速度相匹配，如果设备的速度比较慢，则用户进程只能阻塞。

##### 双缓冲
当块设备使用双缓冲时，现将数据输入第一个缓冲区，装满后输入第二个缓冲区，在向第二个缓冲区送数据的同时，CPU 对第一个缓冲区的数据进行计算，因此在有双缓冲的情况下，系统处理一块数据的时间为 max(C,T)。如果 C < T, 块设备连续输入，CPU 有短时间的等待；如果 C > T, CPU就不必等待设备输入。

##### 循环缓冲
当输入、输出的速度基本相匹配时，可使用双缓冲，但若二者的速度相差甚远，双缓冲的效果就会不太理想，此时可使用多缓冲。典型的多缓冲应用即生产者和消费者问题。

##### 缓冲池
以上所介绍的缓冲只能用于某些特定的进程，它们属于专用缓冲。为了提高缓冲区的龙绿，可采用公用缓冲池，供多个进程共享。缓冲池是由如下所述 3 个缓冲区链队列组成的。
+ 空缓冲区队列 emq，由系统中所有的空闲缓冲区链成。
+ 输入队列 inq，由装满输入数据的缓冲区链成。
+ 输出队列 outq，由装满输出数据的缓冲区链成。

对3个队列操作时类似的，主要有两个操作，一是 AddBuf(Type, number)，将一个由 number 指向的缓冲区挂在某个队列 Type 上；二是 TakeBuf(Type)，从 Type 指示的某个队列上摘下一个缓冲区。

除了上述 3 个队列，系统中有如下所述 4 种工作缓冲区。
+ 用于收容输入数据的工作缓冲区 bin。
+ 用于提取输入数据的工作缓冲区 sin。
+ 用于收容输出数据的工作缓冲区 hout。
+ 用于提取输出数据的工作缓冲区 sout。

缓冲区在以下 4 种工作方式下进行工作。
+ 收容输入。在输入进程需要输入数据时，便调用 GetBuf(emq) 过程，从 emq 队列的队首摘下一空缓冲区，把它作为收容输入工作缓冲区 hin。然后把数据输入其中，之后再调用 PutBuf(inq,hin)过程，将该缓冲区挂在输入队列 inq 的队尾。
+ 提取输入。当计算进程需要输入数据时，调用 GetBuf(inq) 过程，从输入队列 inq 中取下一个缓冲区作为提取输入工作缓冲区 sin，计算进程从中提取数据。计算进程用完数据后，再调用 PutBuf(emq, sin)过程，将该缓冲区挂在空缓冲队列 emq 的队尾。
+ 收容输出。当计算进程需要输出数据时，调用 GetBuf(emq) 过程，从空缓冲队列 emq 中取下一个空缓冲区作为收容输出的工作缓冲区 hout；当其中装满数据后，再调用 PutBuf(outq,hout)过程，将该缓冲区挂在输出缓冲队列的队尾。
+ 提取输出。当输出进程工作时，调用 GetBuf(outq)过程，从输出队列 outq 中取下一个装满输出数据的缓冲区作为提取输出工作缓冲区 sout。在数据取完后，再调用 PutBuf(emq, sout)过程，将该缓冲区挂在空缓冲队列 emq 的队尾。

### 磁盘高速缓存
磁盘高速缓存技术是为了解决磁盘的访问速度远远低于内存的访问速度的瓶颈。

#### 磁盘高速缓存的形式
磁盘高速缓存并非增加高速硬件设备，而是利用内存中的存储空间来暂存从磁盘上读出或来不及写回磁盘的数据。因此，磁盘高速缓存是指一组逻辑上属于磁盘，而物理上驻留在内存的盘块。磁盘高速缓存在内存中有两种形式。
+ 在内存中开辟一个单独的存储空间作为磁盘高速缓存，其大小时固定的，不会受到应用程序的影响。
+ 把内存中难以利用的小存储区域变成一个缓冲池，供请求页式管理系统和磁盘 I/O 共同使用。此时，高速缓存的大小显然不是固定的。

#### 数据交付
数据交付是指将磁盘高速缓存中的数据传送给请求者进程。当有一进程请求访问某个盘块中的数据时，由操作系统先去查看磁盘高速缓冲管理器中是否存在进程所需访问的盘块数据的复制。如有其复制，便直接从高速缓存中提取数据交付给请求者进程，这样就避免了磁盘访问操作。系统可以采用两种方式将数据交给请求者进程。
1. 数据交付。直接将高速缓存中的数据传送给请求者进程的内存工作区。
2. 指针交付。只将指向高速缓存中某区域的指针交付给请求者进程。这种方式所传送的数据量少，因而节省了数据在内存不同区域复制的时间。

#### 提高磁盘 I/O 速度的其他方法。
在系统中设置磁盘高速缓存之后，能显著地减少等待磁盘 I/O 时间。下面介绍几种能有效提高磁盘 I/O 速度的其他方法。
1. 预先读（Read Ahead）。用户进程对文件进行访问时经常采用顺序方法，即顺序地访问文件各盘块的数据。在这种情况下，在读当前盘块时可以预知下一次要读的盘块，因此可以采用预读方式。即在读当前盘块时，提前将下一个盘块（预读块）中的数据页读入磁盘缓冲区。
2. 延迟写。延迟写是指在缓冲区 A 中的数据本应立即写回磁盘，但考虑到该缓冲区中的数据不久之后可能还会再被本进程或其他进程访问（共享数据），因而并不立即将该缓冲区 A 中的数据写入磁盘，而是将它挂在空闲缓冲区队列的末尾。随着空闲缓冲区的使用，缓冲区 A 页慢慢往前移动，直到移动到空闲缓冲区之首。当再有进程申请到该缓冲区时，才将该缓冲区中的数据写入磁盘，而把该缓冲区作为空闲缓冲区分配出去。当该缓冲区 A 仍在队列中时，任何访问该数据的进程，都可以直接读出其中的数据，而不必访问磁盘，这样又可进一步减少磁盘的 I/O 时间。