## 进程与线程

### 什么是进程？

#### 进程的引入
##### 单道程序的顺序执行
在单道程序工作的环境中，“程序”可以理解为“一个在时间上按严格次序先后操作的序列”。顺序执行的程序具有如下特征。
+ 顺序性。程序在处理机上执行时，只有前一个操作结束后，才能执行下一个操作。
+ 封闭性。程序在运行时独占系统中的全部资源，因而系统内资源的状态只有该程序才能改变它，与外界环境无关。
+ 可再现性。当程序被重复执行时，只要其初始条件相同，其执行结果必须相同。
+ 缺点：资源浪费，效率低下。

##### 多道程序的并发执行
为了提高计算机内各种资源的利用率，提高计算机系统的处理能力，允许多个程序同时进入内存并运行，因而并发处理技术得到广泛的应用。程序并发执行的特征：
+ 间断性。程序在并发执行时，由于他们共享系统中的资源或为完成同一任务而相互合作，致使在并发程序之间形成相互制约的关系。
+ 失去封闭性。由于多个程序并发执行共享系统中的各种资源，因而这些资源的状态将由多个程序来改变，致使程序的执行失去了封闭性。
+ 失去可再现性。程序经过多次执行，由于并发执行失去了封闭性，虽然其执行的环境和初始条件是相同的，但得到的结果却不一定相同。

##### 并发环境与并发程序
并发环境：一段时间间隔内，但处理器上有两个或两个以上的程序同时处于开始运行但尚未结束的状态，并且次序不是事先确定的。
并发程序：在并发环境中执行的程序。

#### 进程的概念
为了从变化的角度动态的分析可以并发执行的程序，真实的地反映系统的独立性、并发性、动态性和相互制约，操作系统引入了“进程”的概念。进程是具有独立功能的程序关于某个数据集合上的**一次运行活动**，是系统进行**资源分配**和**调度**的独立单位。

##### 进程和程序的关系
+ 进程的动态性和程序的静态性。进程有创建、就绪、运行、阻塞、撤销等运行状态。而程序是一组有序指令的集合，始终存放在某种介质上。
+ 进程的暂时性和程序的永久性。进程是有生命周期的，有诞生有消亡，短暂的，程序相对是长久的。
+ 结构特征。进程是由程序、数据和进程控制块三部分组成的。而程序只是有序指令的集合。
+ 一个程序可对应多个进程
+ 进程具有创建其他进程的功能
+ 进程更能准确刻画并发，而程序不能

### 进程的组成
进程的活动是通过在CPU上执行一系列程序和对相应数据进行操作来体现的，因此程序和数据是组成进程的实体。为了反映进程的动态特征，需要一个专用的数据结构-进程控制块（Process Control Block，PCB）来描述进程本身的特性、进程的状态、进程的调度信息及对资源的占用情况等。所以，进程映像通常是由程序、数据、栈和 PCB 四部分组成。

##### 进程控制块 
进程控制块是系统感知进程存在的唯一标识。是操作系统用于管理控制进程的一个专门数据结构，记录操作系统所需的用于描述进程情况及控制进程运行的全部信息。它在进程创建时建立，当进程撤销时，进程控制块也随之撤销。主要内容如下：
1. 进程描述信息
    + 进程名。
    + 进程表示符。通常是一个唯一的整数，表示进程的序号。
    + 用户名。创建该进程的用户的名字。
2. 处理机状态信息。该信息主要由处理机的各种寄存器的内容组成。比如通用寄存器、指令计数器、程序状态字寄存器、栈指针等
3. 进程调度信息。进程控制块中存放了一些与进程调度和进程切换有关的信息。包括以下几种。
   1. 进程的状态。指明该进程所处的状态是就绪、阻塞或运行。
   2. 进程的优先级。表示进程获得处理机优先程度的一个整数，优先级高的进程先获得处理机。
   3. 运行统计信息。这些信息与所采用的调度算法有关，其中包括进程已执行时间、进程等待时间等等。
   4. 进程阻塞的原因。记录进程引起阻塞的原因。
4. 进程控制和资源占用信息。
   1. 程序入口地址。进程对应程序和数据的内存地址，当进程被调度执行时，用于找到其程序和数据。
   2. 程序的外存地址。进程被调出时使用的地址。当内存空间紧张时，进程可能被调出内存，当内存有空闲空间时再被重新调入。
   3. 进程同步与通信机制：进程在执行时，可能与其他进程有同步关系或相互通信，进程使用的信号量、消息队列指针等都要存放在PCB中。
   4. 资源占用信息。列出除了CPU之外，进程所需要的全部资源及已经占用的资源情况。
   5. 链接指针。指出本进程所在队列中下一个进程的PCB地址。
   
##### 进程控制块的组织
  进程控制块的组织方式目前常用的是链接方式，链接方式把具有相同状态的进程控制块连接在一起，形成一个运行队列、一个就绪队列、若干个阻塞队列和一个空闲队列。

#### 进程的状态
进程的动态性是由它的状态及状态转换来体现的。
##### 进程的3种基本状态
1. 运行状态：即进程正在处理机上运行的状态。
2. 就绪状态：即进程已经获得了除处理机之外的所有必要资源，只要获得处理机就可以运行的状态。
3. 阻塞状态：当进程由于等待输入输出操作或某个同步事件而暂停运行时，就处于阻塞状态。

##### 3种基本状态的转换
+ 就绪状态->运行状态: 调度程序从就绪状态队列中选择一个进程运行。
+ 运行状态->就绪状态: 正在运行的进程用完了时间片而被暂停运行，或者一个高优先级进程进入就绪状态，抢占正在运行的进程。
+ 运行状态->阻塞状态: 当一个运行状态的进程因需要等待某个事件发生时(请求OS服务、等待I/O结果..)
+ 阻塞状态->就绪状态：当阻塞的原因被解除后，被阻塞的进程并不能立即投入运行，而是从阻塞状态转化为就绪状态继续等待处理机。

##### 创建状态和退出状态
因为进程在创建和退出时操作系统都有很多工作要做，设立这两种状态便于操作系统对进程进行管理。
+ 创建状态：创建状态下进程正在创建过程中，还不能运行。操作系统在创建进程时，要为进程分配 PCB 结构，填写相关内容；为进程分配进程组，连接进程的父子关系；为进程分配所需的资源；为进程建立地址空间，填写有关管理内存的表格，等加载程序等。当把创建好的进程移入就绪队列时，进程从创建状态转化为就绪状态。
+ 退出状态：进程正常或异常结束，操作系统首先要将该进程从运行状态移除，使之成为一个不可能再运行的进程，相应地使进程处于退出状态，并收回其所占的资源。
  
##### 进程的挂起状态
引入挂起状态的原因主要是：
1. 内外存兑换的需要。为了缓和内存紧张的情况，将内存中处于阻塞或者就绪状态的进程换至外存，这样进程由处于有别于阻塞状态的新状态。
2. 用户调试程序的需要。
3. 实时系统中调节负载的需要。

增加了挂起状态之后，对状态的转换影响如下：
+ 阻塞 -> 阻塞挂起：当内存紧张时会引起这种状态的转换。将处于阻塞状态的进程挂起（从内存移到外存），是为了腾出更多内存空间给新创建的进程或就绪的进程。
+ 就绪 -> 就绪挂起：当挂起一些阻塞的进程仍然不能满足内存的需要，或者当有高优先级阻塞的进程和低优先级就绪的进程时，系统会选择首先挂起低优先级就绪的进程，因为系统认为应该让高优先级的进程尽快完成。
+ 运行 -> 就绪挂起：在抢占式分时操作系统中，当高优先级阻塞挂起的进程因事件出现而进入就绪挂起状态时，如果内存空间不够，系统可能将正在运行的进程状态转化为就绪挂起状态。
+ 就绪挂起 -> 就绪：当系统没有了就绪的进程或者当就绪挂起的进程的优先级高于就绪的进程时，会引起这种状态的转换。
+ 阻塞挂起 -> 阻塞。当进程释放了足够的内存空间时，系统会将高优先级阻塞挂起的进程激活，使该进程从外存移到内存。

### 进程的控制
进程控制的职能就是对系统中的全部进程实行有效的管理，其主要表现是对一个**进程进行创建、撤销以及在某些进程状态之间的转移控制**。进程控制操作完成进程各状态之间的转换，由具有特定功能的原语完成。原语是指完成某种特定功能的一段程序，具有不可分割性或不可中断性。比如说进程创建原语、进程撤销原语、阻塞原语、唤醒原语、挂起原语、激活原语等。

#### 核心态和用户态
+ 核心态：具有较高的特权，能执行一切指令，能访问所有寄存器及内存的所有区域。操作系统内核通常运行在系统态。
+ 用户态：具有较低特权的执行状态，只能执行规定的指令、访问指定的寄存器和内存的指定区域。通常用户的程序在用户态下运行，因此用户程序不能直接访问操作系统区域，从而防止用户程序对操作系统的破坏。
+ 通常，程序状态字寄存器中有一位表示处理机的执行状态，这一位根据某些事件的要求而改变，当用户程序需要操作系统服务而调用系统调用时，处理机的执行状态设置为核心态；当系统调用完成返回用户程序时，处理机的执行状态又重置为用户态。

#### 进程的创建
进程创建原语要做的操作
+ 申请空白的PCB。
+ 初始化进程描述信息。
+ 为进程分配资源、分配存储空间。
+ 将新进程插入就绪队列。

#### 进程的撤销（结束进程）
撤销原语要做的工作
+ 查找撤销进程的PCB。根
+ 若进程处于运行状态，予以终止，并进行进程调度。
+ 若进程有子孙，予以终止。当一个进程被撤销时，其所有子孙进程都将被撤销，防止子进程与其进程家族隔离开来而无法控制。
+ 归还资源。收回进程所占用的资源。如关闭打开的文件、断开网络连接、回收分配的内存）
+ 从所在队列移出。

#### 进程的阻塞/唤醒
处于运行状态的进程，在其运行过程种期待某一事件发生，如等待键盘输入、等待磁盘数据传输完成、等待其他进程发送消息，当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态。
阻塞原语需要做的工作
+ 停止进程的执行。
+ 将进程插入到阻塞队列
+ 重新调度
唤醒原语需要的工作
+ 将进程从阻塞队列取下。
+ 把进程插入到就绪队列。
+ 改变进程在PCB中的状态。

#### 进程的挂起与激活
进程的挂起主要是将进程从内存移出。当出现挂起事件时，进程可以将自己挂起或由父进程将其某个子进程挂起。相反，当内存有足够的空间时，将处于挂起状态的进程从外存调回内存，激活进程。
挂起原语要做的工作
+ 检查被挂起进程的状态
+ 若进程处于就绪状态，将进程从就绪状态变为就绪挂起状态。
+ 若进程处于阻塞状态，将进程从阻塞状态变为阻塞挂起状态。
+ 若进程正在运行，则将进程从运行状态变为就绪挂起状态，并调用进程调度程序重新调度。
激活原语要做的工作
+ 检查被激活进程的状态
+ 若进程处于就绪挂起状态，将进程从就绪挂起状态变为就绪状态。
+ 若进程处于阻塞挂起状态，将进程从阻塞挂起状态变为阻塞状态。
+ 若系统采用的是抢占式进程调度，则有新的进程进入就绪队列时，要检查是否要重新调度。如果激活进程的优先级比正在运行进程的优先级高，则会立即剥夺正在运行的进程，把处理机分配给被激活的进程。

#### UNIX的几个进程控制操作（均以系统调用的形式提供）
+ fork() 通过复制调用进程来建立新的进程，是最基本的进程建立过程
+ exec() 包括一系列系统调用，他们都是通过用一段新的程序代码覆盖原来的地址空间，实现进程执行代码的转换。
+ wait() 提供初级进程同步操作，能使一个进程等待另一个进程的结束。
+ exit() 用来终止一个进程的运行

#### UNIX的fork()实现
+ 为子进程分配一个空闲的进程描述符。(proc结构)
+ 分配给子进程唯一标识pid
+  **以一次一页的方式复制父进程地址空间(linux中采用了写时复制技术COW加快创建进程Copy-On-Write)**
+ 从父进程处继承共享资源，如打开的文件和当前工作目录等
+ 将子进程的状态设为就绪，插入到就绪队列
+ 对子进程返回标识符0
+ 向父进程返回子进程的pid

### 其他进程相关的概念
+ 进程的分类：系统进程/用户进程、前台进程/后台进程、CPU密集型进程/IO密集型进程。
+ 进程层次结构：UNIX进程家族树: Init为根； Windows: 地位相同
+ 上下文切换：将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换。

## 线程

### 什么是线程？
线程是进程的一个实体，一种比进程更小的、能独立被调度和分派运行的基本单位。表示进程中的一个控制点，执行一系列命令。它主要有如下部分组成：
+ 线程标识符，它是唯一的
+ 描述处理机状态信息的一组寄存器，包括通用寄存器、指令计数器、程序状态字等。
+ 栈指针，每个线程有自己的用户栈和核心栈两部分。当线程在用户态下运行时使用自己的用户栈，当用户线程转到核心态下运行时使用核心栈。
+ 一个私有存储区，存放现场保护信息和其他与该线程相关的统计信息。

#### 线程的引入（为什么要有线程）
为了减少程序并发执行时所付出的时间和空间的开销，从而提高系统并发执行的程度，进一步提高系统的吞吐量。

#### 线程的状态
与进程相似，线程也有若干种状态，如运行、就绪、阻塞等。

#### 线程的控制
+ 线程的创建：线程创建时，系统为其分配线程控制块、栈等必要的数据结构。一般通过系统调用来创建线程。
+ 线程的撤销。
+ 线程等待。通过系统调用等待某个线程，而使自己变为阻塞状态。
+ 线程让权。线程可以自愿放弃CPU，让其他线程运行。

#### 线程与进程的比较
+ 调度：在同一个进程中，线程的切换不会引起进程的切换，只有当从一个进程的线程切换到另一个进程的线程时，才会引起进程的切换。
+ 并发性：不仅进程之间可以并发执行，同一个进程中的多个线程之间也可以并发执行。
+ 拥有资源：进程是拥有资源的独立单位，线程自己不拥有系统资源，但同一个进程的所有线程共享进程中的资源，如代码段、数据段、打开的文件、IO设备等。
+ 系统开销：创建或撤销进程时，比系统都要为之分配或回收资源，如内存空间、IO设备等。而创建线程不用，因此操作系统所付出的时间和空间开销显著大于重建或撤销线程的开销。类似的，切换进程的环境开销（比如内存映射切换和清除高速缓存）也大于线程的切换开销。

  
### 线程的实现
#### 用户级线程
+ 在用户空间建立线程库：提供一组管理线程的过程。
+ 运行时系统：完成线程的管理工作（操作、线程表）
+ 内核管理的还是进程，不知道线程的存在
+ 线程切换不需要内核态特权

其优点主要如下：
+ 线程切换不需要系统状态的转换。节省了系统从核心态到用户态或从用户态到核心态转换的时间和空间开销。
+ 每个进程可以使用专用的线程调度算法来调度线程。
+ 用户级线程可以在任何操作系统中与新兴，不需要对底层操作系统内核进行修改。

其不足之处主要是：
+ 使用操作系统提供的阻塞系统调用时，进程会被阻塞，因而进程中的所有用户级线程都得不到执行。
+ 在只使用用户级线程的系统中，一个多线程的应用程序不能利用多处理机技术。

#### 内核级线程
在具有内核级线程的系统中，进程只作为资源的拥有者，线程作为调度的单位，每个进程至少有一个线程。内核级线程克服了用户级线程的两个不足。但相对于用户进程，其主要缺点是，在同一个进程中把控制权从一个线程切换给另一个线程需要内核的状态转换（用户态到核心态的转换）。用户级线程与内核级线程的主要区别如下：
+ 切换速度。用户级线程切换可用机器指令，速度快；而内核集线程切换需要内核模式的转换，因而速度慢。
+ 阻塞。当用户级线程使用阻塞系统调用时，会将它整个进程阻塞。而内核级线程不会阻塞它所在的进程。

#### 混合--以上两者结合办法
线程创建在用户空间完成，线程调度在核心态完成。多个用户级线程多路复用多个内核级线程完成功能。

### 多线程相关问题
+ 线程取消。线程取消是指线程在完成任务之前终止。一般的办法是，设立安全点（即检查一个标志是否已确定它可以被取消），当线程处于安全点时才会被取消。
+ 信号处理。
+ 线程池。无限制的线程会耗尽系统自愈啊，如内存和CPU。解决这一问题的方法是使用线程池。线程池的主要思想是在进程开始时创建一定数量的线程，并放入池中等待。线程池的优点如下：
  + 用现有线程处理请求要比创建新线程块
  + 线程池限制了可用线程的数量，这对那些不能支持大量并发线程的系统影响较明显。线程池中的线程数量由系统的CPU数量、物理内存大小和允许并发用户请求的期望值等因素决定。高级的线程池还可以动态调整线程的数量，当系统负荷低时可减低内存消耗。


## 处理器调度（CPU调度）

### CPU调度的相关概念
CPU调度的任务是控制、协调进程对CPU的竞争，按一定的调度算法从就绪队列中选择一个进程，把CPU的使用权交给被选中的进程。如果没有就绪进程，系统会安排一个系统空闲进程或idle进程。主要解决三个问题

#### 调度类型
+ 高级调度：即作业调度。它决定哪个程序可以进入系统中处理，因此它控制多道程序的道数。
+ 中级调度：也称对换程序。引入中级调度的目的是为了提高内存利用率和系统吞吐量。为了使暂时不能运行的进程不再占用宝贵的内存空间，系统将它们调到外存等待，此时进程的状态是挂起状态。当内存空闲时，由中级调度程序决定将外存上那些具备条件的进程重新调入内存。
+ 低级调度：即进程调度。它决定就绪队列中的那个进程获得处理机，然后由分派程序执行把处理机分配给该进程的操作。

#### 调度方式
进程调度方式分为可抢占方式和非抢占方式。
+ 抢占方式：在这种方式下，允许一个进程按照某种原则抢占其他进程占有的处理机。
+ 非抢占方式：采用这种调度方式时，一旦把处理机分配给某个进程，该进程将一直执行下去，直到运行完毕或因某种原因不能运行，绝不允许其他进程强占正在运行进程占有的处理机。
  
#### WHEN：何时进行调度（调度时机）
以下两种情况一定会发生
+ 进程退出。进程正常终止或由于某种错误而终止。当一个进程退出时，必须进行调度。因为进程退出后CPU空闲，必须从就绪队列中选择一个进程投入运行。如果没有就绪进程，通常操作系统提供空转进程。
+ 进程阻塞。当进程由于等待I/O、信号量或其他原因而放弃CPU时，就必须选择另一个进程运行。

另外在其他情况下，虽然不是必需，但还是经常发生。
+ 新进程创建。新创建进程时，新进程的优先级可能高于正在运行的进程，在可抢占方式下，进程调度程序要决定是否让新进程投入运行。
+ 中断发生。当 I/O 设备完成了其工作而发出 I/O 中断时，原来等待该设备的那个进程就会从阻塞状态变为就绪状态。此时，进程调度程序要决定是否选择该进程投入运行。
+ 时钟中断。时钟中断发生时，有可能一个进程运行时间片到了，进程调度程序要决定是否选择其他进程投入运行。

#### WHAT：按什么原则选择下一个执行的进程（调度的性能准则）
在一个操作系统中，调度的目标是按照可以优化系统行为的方式分配处理机时间。调度算法的优劣直接影响该操作系统的性能。通常使用的调度准则，有些事面向用户的，有些是面向系统的。
+ 面向用户的准则：与单个用户感知的系统行为有关。
  + 响应时间：只用户提交一个请求到系统响应（第一次回应）的时间间隔。
  + 周转时间：指一个用户作业被提交到完成的时间间隔。对于每个用户作业来讲，都希望自己作业的周转时间最短。而操作系统的目标是平均周转时间最短，以让大多数用户满意。
  + 等待时间：每个进程在就绪队列中等待的时间
  + 带权周转时间：可以进一步衡量作业在处理机上的实际执行时间和等待时间。带权周转时间 = 周转时间 / 实际执行时间。
  + 优先权：按照进程的紧急程度、进程的大小、进程的等待时间等多种因素给每个进程规定一个优先级，系统调度时，按照优先级的高低选择进程。
  + 截止时间保证：截止时间是衡量实时系统性能的主要指标。
+ 面向系统的准则：主要考虑系统的效率和性能。
  + 系统吞吐量：系统吞吐量是用来评价批处理系统的重要指标。系统吞吐量是指单位时间内所完成的作业数。
  + 处理机的利用率：CPU做有效工作的时间比例。一般的系统中，处理机的利用率为40%-90%。
  + 各类资源的平衡利用：在一个系统汇总，不仅要使处理机的利用率高，而且还应能够有效地利用系统中的其他各类资源，如内存、外存、I/O设备等。一个好的调度算法应尽可能使系统中的所有资源都处于忙碌状态。
  + 公平：在没有用户或系统的特殊要求时，进程应该被公平对待，尽量避免进程被“饿死”

#### HOW：如何让被选中的进程上CPU运行（调度过程）

##### 进程切换
进程切换是指一个进程让出CPU，由另一个进程占用处理器的过程。切换过程包括了对原来运行进程各种状态的保存和对新的进程各种状态的恢复。主要有两部分工作。
+ 切换全局页目录以加载一个新的地址空间
+ 切换内核栈和硬件上下文，其中硬件上下文包括了内核执行新进程需要的全部信息，如CPU相关寄存器。

##### 上下文切换开销
直接开销：内核完成切换所用的CPU时间（保存和恢复寄存器，切换地址空间）
间接开销：高速缓存（Cache）、缓冲区缓存和TLB失效

#### 调度算法

##### 调度算法的设计
设计调度算法要考虑以下几个问题
+ 进程控制块 PCB 中需要记录哪些与 CPU 调度有关的信息。
+ 进程优先级及就绪队列的组织.
+ 抢占式调度和非抢占式调度.
+ I/O 密集型进程与 CPU 密集型进程.
  + I/O 密集型：频繁的进行 I/O。通常会花费很多时间等待操作的完成。
  + CPU 密集型：需要大量的 CPU 时间进行计算
+ 时间片（Time Slice)：一个时间段，分配给调度上CPU的进程，确定了允许该进程运行的时间长度。选择时间片的因素通常由如下几种
  + 进程切换的开销
  + 对响应时间的要求
  + 就绪进程的个数
  + CPU 能力
  + 进程的行为

##### 多处理器调度算法的设计
+ 不仅要决定选择哪一个进程执行，还需要决定在哪一个CPU上执行。
+ 要考虑进程在多个CPU之间迁移时的开销
  + 高速缓存失效、TLB失效
  + 尽可能使进程总是在同一个CPU上执行
  + 如果每个进程可以调度到所有CPU上，假如进程上次在CPU1上执行，本地调度到CPU2，则会增加高速缓存失效、TLB失效；如果每个进程尽量调度到指定的CPU上，各种失效就会减少
+ 考虑负载均衡问题

##### 批处理系统中采用的调度算法
批处理系统中采用的调度算法一般集中在吞吐量、周转时间、CPU利用率。公平、平衡等指标。
+ 先来先服务：非抢占式算法。按照进程就绪的先后顺序使用CPU。特点如下：
  + 公平、实现简单。
  + 有利于长作业，不利于短作业。后来的短作业周转时间较长。
  + 有利于处理机繁忙的作业，不利于 I/O 繁忙的作业。
+ 最短作业优先：非抢占式算法。预计时间最短的进程优先执行。特点如下：
  + 思想：先完成短的作业，改善短作业的周转时间。
  + 优点：改善了平均周转时间和平均带权周转时间，缩短了等待时间。有利于提高系统的吞吐量。
  + 缺点：由于作业的执行时间是估计的，因而准确性不高，从而影响调度性能。不公平，该算法没有考虑作业的紧迫程度。对长作业进程不利，可能使长的任务长时间得不到运行，产生饥饿现象。
+ 最短剩余时间优先: 最短作业优先的抢占式版本。当一个新就绪的进程比当前的进程具有更短的预计剩余时间时，系统抢占当前进程，选择新就绪的进程执行。
+ 最高响应比优先: 调度时，计算每个进程的响应比R；之后，总是选择R最高的进程执行。响应比 R = 周转时间 / 处理时间 = （处理时间 + 等待时间）/ 处理时间 = 1 + （等待时间 / 处理时间）。因为响应比的定义中既考虑了进程的长短，又考虑了进程的等待时间，因此比上述两种更合理。
  
##### 交互式系统中采用的调度算法
交互式系统中关注的指标一般是响应时间、公平、资源平衡。

###### 时间片轮转调度算法。
  + 目标：为短任务改善平均响应时间
  + 解决问题的思路
    + 周期性切换
    + 每个进程分配一个时间片
    + 时钟中断 -> 轮换 
  + 优点：公平，有利于交互式计算，响应时间快
  + 缺点：由于进程切换，时间片轮转算法要花费较高的开销。
  + 时间片的选择：
    + 时间片如果很长，大于一次交互时间，该算法就退化为先来先服务算法。
    + 如果很短，短道一次交互需要几次调度才能完成，系统切换的频率就会很高，频繁的系统切换会导致用户程序响应时间的增长。
    + 因此，时间片长度选择要适当，一般要保证一个基本的交互过程在一个时间片内完成。经验值大概在10-100ms之间，多为50ms。
  + 普通时间片轮转调度不利于IO进程，IO进程往往拥有的时间片较短，再此插入到队尾优先级又不高。故响应时间不好。改进后的轮转调度算法，增加了辅助队列，IO完成后，会进入辅助队列，辅助队列的进程优于就绪队列的进程。
###### 最高优先权调度算法。
  + 选择优先级最高的进程投入运行。通常
    + 系统进程优先级高于用户进程
    + 前台进程优先级高于后台进程
    + 操作系统更偏好IO型进程
    + 优先级可以是静态不变的，也可以动态调整。
    + 缺点：不公平。有可能使低优先级进程产生饥饿问题。
    + 优先级反转问题：在抢占式系统中，一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行。解决方案有如下三种：
      + 设置优先级上限。（进入临界区的进程优先级提高，没进入临界区的低于进入临界区的优先级）
      + 优先级继承。（低优先级进程阻碍了高优先级的基础，则继承高优先级的进程，进行抢占）
      + 使用中断禁止。（进入临界区的进程则不再响应中断）
  + 优先权确定方式通常有两种。静态和动态。
    + 静态优先权。静态优先权是在进程创建时确定该进程的优先权，且该进程的优先权在整个运行期间保持不变。
    + 动态优先权。动态优先权是指进程的优先权可以根据进程的不断推进而改变，以期得到更好的性能。动态优先权的变化取决于进程的等待时间和占有处理机的时间，具体来说，随着进程等待时间的增加，该进程的优先权以某种速率增加。这样做的目的是使优先权较低的进程在的鞥带足够的时间后，其优先权提高，进而被调度执行。
###### 多级反馈队列调度算法（BSD采用的算法）
  + 是一个综合调度算法（折衷权衡）
  + 设置多个就绪队列，第一级队列优先级最高
  + 给不同就绪队列中的进程分配长度不同的时间片，第一级队列时间片最小；随着队列优先级别的降低，时间片增大。
  + 当第一级队列为空时，在第二级队列调度。以此类推。
  + 各组队列按照时间片轮转方式进行调度。
  + 当一个新创建进程就绪后，进入第一级队列。
  + 进程用完时间片而放弃CPU，进入下一级就绪队列。
  + 由于阻塞而放弃CPU的进程进入相应的等待队列，一旦等待的事件发生，该进程回到原来一级就绪队列。
  