#### 常见问题

##### 试着说明运输层在协议栈中的地位和作用。运输层的通信和网络层的通信有什么重要的区别？为什么运输层是必不可少的？
从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。

网络层提供主机之间的逻辑通信，而运输层提供应用进程之间的逻辑通信。网络层只负责首部的校验，运输层有复用、分用、对收到的报文进行差错检测功能，因此运输层是必不可少的。

##### 当应用程序使用面向连接的 TCP 和无连接的 IP 时，这种传输是面向连接的还是无连接的？
这要在不同层次来看。在运输层是面向连接的，而在网络层则是无连接的。

##### 试着举例说明有些应用程序愿意采用不可靠的 UDP，而不愿意采用可靠的 TCP。
首先，在互联网上传输实时数据的分组时，有可能会出现差错甚至丢失。如果利用 TCP 协议对这些出错或丢失的分组进行重传，那么时延就会大大增加。因此，实时数据的传输在运输层就应采用用户数据报协议 UDP，而不使用 TCP 协议。这就是说，对于传送实时数据，我们宁可丢失少量分组（当然不能丢失太多，否则重放的质量就太差了），也不要等待太晚到达的分组。在连续的音频或视频数据流中，很少量分组的丢失对播放效果的影响并不大（因为这是由人来进行主观评价的），因而使可以容忍的。在这种情况下，我们愿意采用不可靠的 UDP，而不愿意采用可靠的 TCP。

其次，当网络出现拥塞时，TCP 的拥塞控制就会让 TCP 的发送方放慢报文段的发送。可能有的应用程序就不愿意放慢其报文段的发送速度。另外，可能有的应用程序不需要 TCP 的可靠传输。在这些情况下，就宁可使用 UDP 来传送。

##### 接收方收到有差错的 UDP 用户数据报时应如何处理？
简单的丢弃。

##### 如果应用程序愿意使用 UDP 完成可靠传输，这可能吗？请说明理由。
这是可以的。但这要由应用层自己来完成可靠传输。例如，应用层自己使用可靠传输协议。

##### 为什么说 UDP 是面向报文的，而 TCP 是面向字节流的？
发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，即一次发送一个完整的报文。在接收方的 UDP，对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程。因此，应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。反之，若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率。

##### 端口的作用是什么？
端口是用来标志进程的。端口号只具有本地意义，它指示为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网中不同的计算机中，相同的端口号是没有关联的。

##### 试着说明运输层伪首部的作用。
所谓“伪首部”是因为这种伪首部并不是 UDP 用户数据报或 TCP 报文段真正的首部。只是在计算检验和时，临时添加在 UDP 用户数据报或 TCP 报文段的前面，得到一个临时的 UDP 用户数据报或 TCP 报文段。检验和就是按照这个临时的 UDP 用户数据报或 TCP 报文段来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算运输层的检验和。

##### 某个应用进程使用运输层的用户数据报 UDP，然后继续向下交给 IP 层后，又封装成 IP 数据报。既然都是数据报，是否可以跳过 UDP 而直接交给 IP 层？哪些功能 UDP 提供了但 IP 没有提供？
IP 数据报只能找到目的主机而无法找到目的进程。如果应用进程直接把数据交给下面的 IP 层，那么在传送到对方 IP 层后，但不知道交付哪一个应用进程。UDP 提供对应用进程的复用和分用功能，以及提供对数据部分的差错检验，这些功能 IP 层没有提供。

##### 一个应用程序用 UDP，到了 IP 层把数据报再划分为 4 个数据报片发送出去。结果前两个数据报分片丢失，后两个到达目的站。过了一段时间应用程序重传 UDP，而 IP 层仍然划分为 4 个数据报片来发送。结果这次前两个到达目的站而后两个丢失。试问：在目的站能否将这两次传输的 4 个数据报片组装成为完整的数据报？假定目的站第一次收到的后两个数据报片仍然保存在目的站的缓存中。
不行。重传时，IP 数据报的标识字段会有另一个标识符。仅当标识符相同的 IP 数据报片才能组装成一个 IP 数据报。前两个 IP 数据报片的标识符与后两个 IP 数据报片的标识符不同，因此不能组装成一个 IP 数据报。

##### 一个 UDP 用户数据报的数据字段为 8192 字节。在链路层要使用以太网来传送。试问应当划分为几个 IP 数据报片？说明每一个 IP 数据报片的数据字段长度和片偏移字段的值。
UDP 用户数据报的长度 = 8192 + 8 = 8200 B。以太网数据字段最大长度是 1500 B。IP 首部最小为 20 B，则 IP 数据报的数据部分最多只能有 1480 B。8200 = 1480 * 5 + 800。因此花粉的数据报片共 6 个。
第 1 个数据报片的片偏移字节是 0。
第 2 个数据报片的片偏移字节是 1480 B。
第 3 个数据报片的片偏移字节是 2960 B。
第 4 个数据报片的片偏移字节是 4440 B。
第 5 个数据报片的片偏移字节是 5920 B。
第 6 个数据报片的片偏移字节是 7400 B。数据字段长度 800。

##### 一个 UDP 用户数据报的首部的十六进制表示是 06 32 00 45 00 1C E2 17。试求源端口、目的端口、用户数据报的总长度、数据部分长度。这个用户数据报是从客户端发送给服务器还是从服务器发送给客户？使用 UDP 的这个服务器程序是什么？
源端口： 0x0632 -> 1586
目的端口： 0x45 —> 69
数据报总长度：0x001c -> 28 字节
数据部分长度：28 - 8 = 20 字节。
此 UDP 用户数据报是客户发给服务器，因为目的端口 < 1023，是熟知端口。服务器程序是 TFTP。

##### 使用 TCP 对实时话音数据的传输有没有什么问题？使用 UDP 在传送数据文件时会有什么问题？
对实时话音数据的传输是不能使用 TCP 的。这是因为用 TCP 传输话音数据时，只要已出现差错或丢失，TCP 就要重传。这就产生了额外的时延，有时这种时延会达到很高的数值，使接收方无法容忍。在实时话音通信中，人们宁可丢掉几个分组，也不愿意收到太迟来到的分组，因为这样会使重放的话音质量严重恶化。虽然 UDP 不保证可靠交付，但 UDP 比 TCP 的开销小很多。因此只要应用程序接受这样的服务质量就可以使用 UDP。
使用 UDP 传送数据文件时，如果出现了差错，UDP 仅仅是少收了这个出错的报文段，并不通知发送方重传。这样就不能保证正确地传送数据。因此在传送数据文件时，我们都是采用 TCP 来传送的。

##### 在停止等待协议中，如果不使用编号是否可行？为什么？
在停止等待协议中，如果不使用编号不可行的。试考虑一个例子。
+ A 发送报文段 M1，B 收到后发送确认（不编号）。但这个确认很晚才传送到A。A 在没有等到确认时，超时重传了 M1。B 发送的第一个确认最后到了 A，于是 A 发送下一个报文段 M2，但 M2 丢失了。B 收到 A 发送的重传的 M1。由于 B 并不知道是重传的，因为报文段没有编号。所以 B 无法判断是重传的老报文段还是新的报文段。B 只能把 A 发送的重传的 M1 收下，并发送确认。但这个确认使 A 认为是对其发送的 M2 的确认，于是认为发送的两个报文段 B 都收到了。
  
从这个例子中看出，不使用编号，A 以为发送的两个报文段都正确地传送到 B，而实际上 B 收到了两个重复的报文段。可见在停止等待协议中，如果不使用编号是不可行的。

##### 在停止等待协议中，如果收到重复的报文段时不予理睬(即悄悄地丢弃它，而其他什么也不做），是否可行？试举出具体例子说明理由。
举例：A 发送报文段 M1，B 收到后发送确认，但这个确认在网络核心中丢失了。于是 A 超时重传报文段 M1，而 B 收到后不予理睬，这就导致 A 再次超时重传报文段 M1，B 继续不理睬，A 继续超时重传，陷入死循环...，可见，如果收到重复的报文段时不予理睬是不行的。

##### 在连续 ARQ 协议中，若发送窗口等于 7，则发送端在开始时可连续发送 7 个分组。因此，在每一分组发出后，都要置一个超时计时器，限制计算机里只有一个硬时钟。设这 7 个分组发出的时间分别是 t0，t1，t2，t3，t4，t5，t6。且 tout都一样大，试问如何实现这 7 个超时计时器（这叫软时钟法）？
用相对发送时间实现一个链表。每个结点信息包括：分组的序号、指向下一分组的指针，分组发送的相对时间。首个分组（头结点）的相对时间就是 t0。后面的是 t1 - t0，t2 - t1，以此类推。计算超时时间用硬时间加上链表结点的相对时间。

##### 假定使用连续 ARQ 协议，发送窗口大小是 3，而序号范围是[0, 15]，而传输媒体保证在接收方能够按序收到分组。在某一时刻，在接收方，下一个期望收到的序号是 5。试问：1）在发送方的发送窗口中可能出现的序号组合有哪些？2）接收方已经发送出的、但仍滞留在网络中（即未到达发送方）的确认分组，可能有哪些？说明这些确认分组是用来确认哪些序号的分组。
分别回答如下。
1. 在接收方，下一个期望收到的序号是 5。这表明序号到 4 为止的分组都已收到。若这些确认都已到达发送方，则发送窗口最靠前，其范围是[5, 7]。假定所有的确认都已丢失了，发送方都没有收到这些确认。这时，发送窗口最靠后，应为 [2, 4]。因此，发送窗口可以是 [2,4],[3,5],[4,6],[5,7] 中的任何一个。
2. 接收方期望收到序号为 5 的分组，说明序号 2，3，4 的分组都已收到，并且已发送了确认。对序号为 1 的分组的确认肯定被发送方收到了，否则发送方不可能发送 4 号分组。可见，对序号为 2，3，4 的分组的确认有可能仍滞留在网络中。这些确认是用来确认序号为 2，3，4 的分组的。

##### 主机 A 向主机 B 发送一个很长的文件，其长度为 L 字节，假定 TCP 使用的 MSS 为 1460 字节。1）在 TCP 的序号不重复使用的条件下，L 的最大值是多少？ 2）假定使用上面计算出的文件长度，而运输层、网络层和数据链路层所用的首部开销共 66 字节，链路的数据率为 10 Mbit/s，试求这个文件所需的最短传输时间。
1. TCP 首部序号是 4 个字节，32 位。序号是数据字段每一个字节的编号，如果要求不重复使用序号，故 L 的最大长度为 2^32 = 4 GB。
2. 2^32 / 1460 = 2941758.422，需要发送 2941759 个数据帧。已知帧首部的开销是 66 * 2941759 = 194156094 字节。故发送的总字节数为 2^32 + 194156094 = 4489123390 字节。又已知数据率 10Mbit/s = 1.25MB/s = 1250000 字节/秒。故最后发送最短传输时间需要 4489123390 / 1250000 = 3591.3 秒 约 1 小时。

##### 主机 A 向主机 B 连续发送了两个 TCP 报文段，其序号分别是 70 和 100。试问：1）第一个报文段携带了多少字节的数据？2）主机 B 收到第一个报文段后，发回的确认中的确认号应当是多少？3）如果 B 收到第二个报文段后，发回的确认中的确认号是 180，试问 A 发送的第二个报文段中的数据有多少字节？4）如果 A 发送的第一个报文段丢失了，但第二个报文段到达了 B。B 在第二个报文段到达后向 A 发送确认。试问这个确认号应为多少？
1. 第一个报文段的数据序号是 70 到 99，共 30 字节的数据。
2. B 期望收到下一个报文段的第一个数据字节的序号是100，因此确认号应为 100。
3. A 发送的第二个报文段中的数据中的字节数是 100 ~ 179 共 80 字节。
4. B 在第二个报文段到达后向 A 发送确认，其确认号应为 70。

##### 一个 TCP 连接下面使用 256 kbit/s 的链路，其端到端时延为 128ms。经测试，发现吞吐量只有 120 kbit/s。试问发送窗口 W 是多少？（提示：可以有两种答案，取决于接收端发出确认的时机）
设发送窗口 = W(bit)，再设发送端连续发送完窗口内的数据所需的时间 = T。有两种情况：
1. 接收端在收完一批数据的最后才发出确认，因此发送端经过 （256 + T）后才能发送下一个窗口的数据。
2. 接收端每收到一个很小的报文段后就发回确认，因此发送端经过比 256 略多一些的时间即可再发送数据。因此每经过 256ms 就能发送一个窗口的数据。
```
    对于 1. 吞吐量 =  W / ( (W / 256kbit/s) + 256ms ) = 120 kbit/s
    --> 可推导出 
        发送窗口 W = 57825.88 bit， 约为 7228 字节。

    对于 2. 吞吐量 = W / 256ms = 120 kbit/s
                W = 30720 bit = 3840 B
```

##### 为什么在 TCP 首部中有一个首部长度字段，而 UDP 的首部中就没有这个字段？
TCP 首部除固定长度部分外，还有选项，因此 TCP 首部长度时可变的。UDP 首部长度是固定的，不需要这个字段。

##### 一个 TCP 报文段的数据部分最多为多少个字节？为什么？如果用户要传送的数据的字节长度，超过 TCP 报文段中的序号字段可能编出的最大序号，问还能否用 TCP 来传送。
一个 TCP 报文段的数据部分最多为 65495 字节。数据部分 + TCP最小首部 20 字节 + IP 最小首部 20 字节 ≤ IP 数据报最大长度 65535 字节。故 TCP 报文段数据部分最多为 65495 字节。

如果用户要传送的数据的字节长度超过 TCP 报文段中的序号字段可能编出的最大序号，仍可用 TCP 来传送。编号用完后再重复使用。但应设法保证不出现编号的混乱。

##### 主机 A 向主机 B 发送 TCP 报文段，首部中的源端口是 m 且目的端口是 n。当 B 向 A 发送回信时，其 TCP 报文段的首部中的源端口和目的端口分别是什么？
+ 源端口：n。
+ 目的端口：m

##### 在使用 TCP 传送数据时，如果有一个确认报文段丢失了，也不一定会引起与该确认报文段对应的数据的重传。试说明理由。
还未重传就收到了对更高序号的确认。

##### 设 TCP 使用的最大窗口为 65535 字节，而传输信道不产生差错，带宽也不受限制。若报文段的平均往返时间为 20ms，问所能得到的最大吞吐量为多少？
最大数据率 = （65535 * 8）bit / 20 ms 约等于 26.2Mbit/s

##### 通信信道带宽为 1Gbit/s，端到端传播时延为 10ms。TCP 的发送窗口为 65535 字节。试问：可能达到的最大吞吐量是多少？信道的利用率时多少？
发送一个窗口的比特数为 65535 * 8 = 524280 bit。
```
    传输时延 = 524280 bit / (1 * 10^9 bit/s) = 0.524 ms
    往返时间 = 10ms * 2 + 0.524 ms = 20.524ms
    最大吞吐量为 524280 bit / 20.524 ms ≈ 25.5 Mbit/s
    信道利用率为 25.5 Mbit/s / 1000 Mbit/s = 2.55 %
```

##### 试计算一个包括五段链路的运输连接的单程端到端时延。五段链路中有两是是卫星链路，有三段是广域网链路。每条卫星链路又由上行链路和下行链路两部分组成。可以取这两部分的传播时延只和为 250 ms。每一个广域网的范围为 1500km，其传播时延可按 150000 km/s 来计算。各数据链路速率为 48 kbit/s，帧长为 960 位。
```
    广域网传播时延 = 1500 km/ 150000 km/s = 10 ms
    每一个结点的传输时延 = 960 bit / 48000 bit/s = 20 ms
    故 端到端的时延 = 250 ms * 2 + 10 ms * 3 + 20 ms * 5 = 630 ms 
```

##### 在 TCP 的拥塞控制中，什么是慢开始、拥塞避免、快重传和快恢复算法？这里每一种算法各起什么作用？“乘法减小”和“加法增大”各用在什么情况下？
慢开始的算法的思路是这样的：当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况，经验证明，较好的方法时先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个 MSS 的数值，用专业的方法逐步增大发送方的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。使用慢开始算法后，每经过一个传输轮次，拥塞窗口 cwnd 就加倍。

为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh 状态变量。 当 cwnd > ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。

拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍。这样，拥塞窗口 cwnd 按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

快重传算法首先要求接收方每收到一个失序的报文段后，就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等待自己发送数据时才进行捎带确认。

快恢复算法，其过程有以下两个要点。
1. 当发送方连续收到三个重复确认时，就执行“乘法减小“算法，把慢开始门限 ssthresh 减半。这是为了预防网络发送拥塞。请注意，接下去不执行慢开始算法。
2. 由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把 cwnd 值设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（”加法增大”），使拥塞窗口缓慢地线性增大。

"乘法减小“无论在慢开始阶段还是拥塞避免阶段，只要出现超时（即很可能出现了网络拥塞），就把慢开始门限值 ssthresh 减半，即设置为当前的拥塞窗口的一半（与此同时，执行慢开始算法）。当网络频繁出现拥塞时，ssthresh 值就下降的很快，以大大减少注入到网络中的分组数。

“加法增大”是指执行拥塞避免算法后，使拥塞窗口缓慢增大，以防止网络过早出现阻塞。

##### TCP 在进行流量控制时，是以分组的丢失作为产生拥塞的标志。有没有不是因拥塞而引起分组丢失的情况？如有，请举出三种情况。
不是因拥塞而引起分组丢失的情况是由的，举例如下。
1. 当 IP 数据报在传输过程中需要分片，但其中的一个数据报片未能及时到达终点，而终点组装 IP 数据报已超时，因而只能丢弃该数据报。
2. IP 数据报已经到达终点，但终点的缓存没有足够的空间存放此数据报。
3. 数据报在转发过程中经过一个局域网的网桥，但网桥在转发该数据报的帧时没有足够的存储空间而只好丢弃。

##### 在连接释放过程中， ESTABLISHED 状态下，B 能否下不发送 ack = u + 1 的确认？（因此 B 在后面要发送的连接释放报文段中，仍有 ack = u + 1 这一信息。）
如果 B 不再发送数据了，可以把两个报文段合并成为一个，即只发送 FIN + ACK 报文段。但如果 B 还有数据要发送，那就不行，因为 A 迟迟收不到确认，就会以为刚才发送的 FIN 报文段丢失了，就超时重传这个 FIN 报文段，浪费网络资源。

##### 在什么情况下会发生从状态 SYN-SENT 到状态 SYN-RCVD 的变迁？
当 A 和 B 都作为客户，即同时主动打开 TCP 连接。这时的每一方的状态变迁都是：
```
    CLOSED -> SYN-SENT -> SYN-RCVD -> ESTABLISHED
```

##### 试以具体例子说明为什么一个运输连接可以有多种方式释放。可以设两个互相通信的用户分别连接在网络的两结点上。
设 A 是客户，B 是服务器。A 和 B 建立了 TCP 连接后，A 向 B 传送一个文件，当 A 收到来自 B 的确认后，文件的传送任务就完成了。A 就释放 TCP 连接，B 也随之释放 TCP 连接。这是最简单的一种连接释放方法。
但也可以有另一种情况。A 发送一个文件，里面含有一些数据。需要 B 进行修改。B 收到文件后就发送了确认。A 收到确认报文段后，就可以释放 TCP 连接，因为 A 已经没有数据要向 B 发送了，可以向 B 发送 FIN 报文段，然后 B 给出确认。这时的 TCP 连接就处于半关闭状态。A 不能再发送数据了，但 B 可以发送数据。等 B 向 A 发送完修改后的数据，B 再向 A 发送 FIN 报文段，A 确认后，TCP 连接就释放了。这是另一种连接释放的方法。

##### 解释为什么突然释放运输连接就可能会丢是用户数据，而使用 TCP 的连接释放方法就可保证不丢失数据。
假定 A 和 B 之间建立了 TCP 连接，并且已经交换了一些数据。现在 A 应当发送的数据都已经发送完毕了。如果 A 现在突然把 TCP 连接释放调，那么有可能出现这种情况：A 发送给 B 的某些报文段正在网络中传送，但因某种原因，报文段丢失了。A 以为 B 应当收到 A 所发送的全部报文段，但事实上，有些报文段 B 没有收到。这就是题目所说的“可能会地丢失用户数据”。
再假定 A 已经收到了来自 B 的确认，B 向 A 确认已经收到了 A 所发送的全部数据。如果 A 现在突然把 TCP 连接释放调，那么 A 发送给 B 的数据时不可能丢失了，因为 B 已经确认收到了 A 所发送的全部数据。现在可能会丢失的，是 B 无法向 A 发送一些数据了（如果 B 还有这样的数据），因为 TCP 连接已经突然释放了。
因此，必须使用 TCP 的连接释放，这样就可保证不丢失数据。

##### 试用具体例子说明为什么在运输连接建立时要使用三报文握手。说明如不这样做可能会出现什么情况。
假定。在上一个 TCP 连接中，A 向 B 发送的连接请求 SYN 报文段滞留在网络中的某处。于是 A 超时重传，与 B 建立了 TCP 连接，交换了数据，最后也释放了 TCP 连接。
但滞留在网络中的某处的陈旧的 SYN 报文段，现在突然传送到了 B。如果不使用三报文握手，那么 B 就认为 A 现在请求建立 TCP 连接，于是就分配资源，等待 A 传送数据。但 A 并没有想要建立 TCP 连接，也不会向 B 传送数据。B 就白白等待着 A 发送数据。
如果使用三报文握手，那么 B 在收到 A 发送的陈旧的 SYN 报文段后，就向 A 发送 SYN 报文段，选择自己的序号 seq = y， 并确认收到 A 的 SYN 报文段，其确认号 ack = x + 1，当 A 收到 B 的 SYN 报文段时，从确认号就可得知不应当理睬这个 SYN 报文段（因为 A 现在并没有发送 seq = x 的 SYN 报文段）。这时，A 发送复位报文段，在这个报文段中，RST = 1，ACK = 1，其确认号 ack = y + 1，我们注意到，虽然 A 拒绝了 TCP 连接的建立（发送了复位报文段），但对 B 发送的 SYN 报文段还是确认收到了。
B 收到 A 的 RST 报文段后，就知道不能建立 TCP 连接，不会等待 A 发送数据了。

##### 网络允许的最大报文段长度为 128 字节，序号用 8 位表示，报文段在网络中的寿命为 30 秒，求发送报文段的一方所能达到的最高数据率。
根据提议，本题应当有一些假定。
1. 本题不是使用 TCP 协议，因为序号字段是 8 位，而不是 TCP 的 32 位。
2. 既然不是 TCP 协议，首部也不会是 TCP 首部，目前只知道报文段的首部中有一个序号字段。
3. 显然，现在不是给报文中的每一个字节编上序号，而是给每一个报文编一个序号。
4. 报文段的传送应当使用滑动窗口协议（而不是停止等待协议），这样就可得到较高的效率。

我们直到，在使用滑动窗口协议 时，在没有收到确认的情况下，8 位的序号字段可连续发送 255 个序号的报文段。这样，一共可发送的比特数是：255 * 128 * 8 = 261120 bit。算出发送报文段的一方所能达到的最高数据率是：261120 bit / 30 s = 8704 bit/s = 8.704 kbit/s。

##### UDP 和 IP 的不可靠程度是否相同？请加以解释。
UDP 和 IP 都是无连接的协议和不可靠传输的协议。UDP 用户数据报和 IP 数据报的首部都有检验和字段。当检验出差错时，就把收到的 UDP 用户数据报或 IP 数据报丢弃。这是它们的相同之处。
但 UDP 和 IP 的可靠性是有些区别的。UDP 用户数据报的检验和是既检验 UDP 用户数据报的首部又检验整个的数据部分，而 IP 数据报的检验和仅仅检验 IP 数据报的首部。UDP 用户数据报的检验和还增加了伪首部，即还检验了下面的 IP 数据报的源 IP 地址和目的 IP 地址。

##### UDP 用户数据报的最小长度是多少？用最小长度的 UDP 用户数据报构成的最短 IP 数据报的长度是多少？
UDP 用户数据报的最小长度是 8 字节。即仅有首部而没有数据。用最小长度的 UDP 源用户数据报构成的最短 IP 数据报的长度是 28 字节。此 IP 数据报具有 20 字节的固定首部，首部中没有可选字段。

##### 某客户使用 UDP 将数据发送给一服务器，数据共 16 字节。试计算在运输层的传输效率（有用字节与总字节之比）。在 IP 层的传输效率呢？假定 IP 首部无选项。在数据链路层的传输效率呢？假定数据链路层使用以太网。
UDP 用户数据报的总长度 = 8 + 16 = 24 字节。因此，在运输层的传输效率 = 16 / 24 = 0.667。
IP 数据报的总长度 = 20 + 24 = 44 字节。因此，在 IP 层的传输效率 = 16 / 44 = 0.364。
以太网有 14 字节的首部。4字节的尾部（FCS字段）。但其数据字段的最小长度是 46 字节。而我们的 IP 数据报仅有 44 字节，因此还必须加上 2 字节的填充。这样，以太网的总长度 = 14 + 4 + 2 + 44 = 64 字节。因此，在数据链路层的传输效率 = 16 / 64 = 0.25。如果再考虑到发送以太网的帧之前还有 8 字节的前同步码。把这 8 字节计入后，在数据链路层的传输效率 = 16 / 72 = 0.222。

#### 某客户有 67000 字节的分组。试说明怎样使用 UDP 数据报将这个分组进行传送。
一个 UDP 用户数据报的最大长度是 65535 字节。现在的长度超过了这个限度，因此不能使用一个 UDP 用户数据报来传送。必须进行分割（例如，分割成为两个 UDP 用户数据报），使其长度不超过以上的限度。

##### TCP 连接处于 ESTABLISHED 状态，以下的事件相继发生。在每一个事件之后，连接的状态是什么？在每一个事件之后发生的动作是什么？ 1） 收到一个 FIN 报文段。 2） 应用程序发送”关闭“报文。
1. 处于 ESTABLISHED 状态且能够收到一个 FIN 报文段的，只有 TCP 的服务端而不会是客户端。当这个服务器收到 FIN 报文段时，服务器就向客户端发送 ACK 报文段，并进入到 CLOSE-WAIT 状态。这是被动关闭。这时客户端不会再发送数据了，但服务端如还有数据要发送给客户端，那么还是可以继续发送的。
2. 应用程序发送“关闭”报文给服务器，表明没有数据要发送了。这时服务器就应当发送 FIN 报文段给客户，然后转换到 LAST-ACK 状态，并等待来自客户端的最后的确认。

##### TCP 连接处于 FIN-WAIT-1 状态，以下的事件相继发生。在每一个事件之后，连接的状态是什么？在每一个事件之后的动作是什么？1）收到 ACK 报文段。 2）收到 FIN 报文段。 3）发生了超时。
1. 处于 FIN-WAIT-1 状态的只有 TCP 客户端。当收到 ACK 报文段后，TCP 客户不发送任何报文段，指示从 FIN-WAIT-1 状态进入到 FIN-WAIT-2 状态。
2. 在收到 FIN 报文段后，TCP 客户端发送 ACK 报文段，并进入到 TIME-WAIT 状态。
3. 当发生了超时，也就是在经过 2 MSL 时长后，TCP 客户进入到 CLOSED 状态。


##### 主机 A 通过 TCP 连接向 B 发送一个很长的文件，因此这需要分成很多歌报文段来发送。假定某一个 TCP 报文段的序号是 x，那么下一个报文段的序号是否就是 x + 1 呢？
假定某一个 TCP 报文段的序号是 x，那么下一个报文段的序号应当是 x + n，这里的 n 是这个报文段中的数据长度的字节数。如果 n = 400，那么下一个报文段的序号应当是 x + 400。若在报文段中仅有一个字节的数据，则下一个报文段的序号才是 x + 1。

##### TCP 的吞吐量应当是每秒发送的数据字节数，还是每秒发送的首部和数据之和的字节数？吞吐量应当是每秒发送的字节数，还是每秒发送的比特数？
TCP 的吞吐量本来并没有标准的定义，可以计入首部，也可以不计入首部，但应当说清楚。不过，从拥塞控制来看，拥塞窗口和发送窗口针对的都是 TCP 报文段中的数据字段，而重要的参数 MSS 也是指 TCP 报文段中的数据字段的长度。因此，把 TCP 的吞吐量定义为每秒发送的数据字节数是比较方便的。
计算机内部的数据传送时以每秒多少字节作为单位的，而在通信线路上的数据率则常用每秒多少比特作为单位。这两种表示方法并无实质上的差别。在上面的习题中，因为 MSS 是用字节作为单位，因此，用每秒发送多少字节作为 TCP 吞吐量的单位就比较简单一些。

##### 在 TCP 的连接建立的三报文握手过程中，为什么第三个报文段不需要对方的确认？这会不会出现问题？
关于这个问题，还不能简单地用“是”或“否”来回答。
我们假定 A 是客户端，是发起 TCP 连接建立的一方。再假定三报文我收过程中的第三个报文段丢失了，而 A 并不知道。这时，A 以为对方收到了这个报文段，以为 TCP 连接已经建立了，于是就开始发送数据报文段给 B。B 由于没有收到三报文握手中的最后一个报文段，因此 B 就不能进入 TCP 的 ESTABLISHED 状态。B 的这种状态可以叫做"半开连接“，即仅仅把 TCP 连接打开了一半。在这种状态下，B 虽然已经初始化了连接变量和缓存，但是不能够接收数据。通常，B 在经过一段时间后（例如，一分钟后），如果还没有收到来自 A 的确认报文段，就终止这个半开连接状态，那么 A 就必须重新建立 TCP 连接。因此在这种情况下，第三个报文段的丢失，就导致了 TCP 连接无法建立。
但是，假定 A 在这段时间内，紧接着就发送了数据。我们知道，TCP 具有累积确认的功能。在 A 发送的数据报文段中，自己的序号没有改变，仍然是和丢失的确认帧的序号一样（丢失的那个确认帧不消耗序号），并且确认位 ACk = 1，确认号也是 B 选择的初始序号加 1.当 B 收到这个报文段后，从 TCP 的首部就可以知道，A 已确认收到了 B 刚才发送的 SYN + ACK 报文段，于是就进入了 ESTABLISHED 状态。接着，就接受 A 发送的数据。在这种情况下，第三个报文段的丢失对 TCP 的连接建立没有影响。
大家知道，A 在发送第二个报文段时，可以有两种选择。
1. 仅仅是确认而不携带数据，数据接着在后面发送。
2. 不仅是确认，而且携带上自己的数据

在第一种选择时，A 在下一个报文段发送自己的数据。但下一个报文段的额首部中仍然包括了对 B 的 SYN + ACK 报文段的确认，即和第二种选择发送的报文段一样。
在第二种选择时，A 省略了单独发送一个确认报文段。
从这里也可以看出，A 发送的第二个仅仅是确认的报文段，是个可以省略的报文段，即使丢失了也无妨，只要下面紧接着就发送数据报文段即可。

##### 流量控制和拥塞控制的最主要的区别是什么？发送窗口的大小取决于流量控制还是拥塞控制？
简单地说，流量控制是在一条 TCP 连接中的接收端采用的措施，用来限制对方（发送端）发送报文段的速率，一面在接收端来不及接收，流量控制只控制一个发送端。
拥塞控制是用来控制 TCP 连接中发送端发送报文段的速率，以免使互联网中的某处产生过载。拥塞控制可能会同时控制许多个发送端，限制它们的发送速率。不过每一个发送单只知道自己应当怎样调整发送速率，而不知道在互联网中还有哪些主机被限制了发送速率。我们直到，发送窗口的上限值是 Min(rwnd, cwnd)，即发送窗口的数值不能超过接收窗口和拥塞窗口中的较小的一个。接收窗口的大小体现了接收端对发送端对发送端施加的流量控制，而拥塞窗口的大小则是整个互联网的负载情况对发送端施加的拥塞控制。因此，当接收窗口小于拥塞窗口时，发送窗口的大小取决于流量控制，即取决于接收端的接收能力。但当拥塞窗口小于接收窗口时，则发送窗口的大小取决于拥塞控制，即取决于整个网络的拥塞状况。

##### TCP 对拥塞控制采用的是动态调整的策略。能否给出动态调整的要点？
1. 探测网络的拥塞水平。慢开始就是从发送一个报文段开始探测网络的。
2. 如果网络没有拥塞，就加快发送速率。在慢开始和拥塞避免阶段都是这样。
3. 如果网络可能发生了拥塞，就降低发送速率。例如，回到慢开始，或让门限值 ssthresh 减半。

##### TCP 协议时面向连接的，但 TCP 使用的 IP 协议却是无连接的。这两种协议都有哪些主要的区别？
+ TCP 提供的服务包括：面向连接的服务，字节流接口，有流量控制、有拥塞控制、保证可靠性（无丢失、无重复、按序交付）
+ IP 提供的服务是：无连接的服务，IP 数据报接口，无流量控制、无拥塞控制、不保证可靠性（可能丢失、可能重复、可能失序）

显然，TCP 提供的功能和服务要比 IP 所能提供的多得多。这是因为 TCP 使用了诸如确认、窗口通知、计时器等级制，因而可以检测出有差错的报文、重复的报文、和失序的报文。

##### IP 和 UDP 的一个共同点就是它们都是无连接的，IP 和 UDP 最主要的区别是什么？
IP 是主机到主机的通信协议，但 UDP 是进程到进程的通信协议。




##### 常见的五层模型每一层的作用，分别解决什么问题？

##### 分组从源端到目的端传输时会产生什么问题？为什么会产生这些问题？
1. 出错。
2. 丢失。
3. 失序。
4. 重复。

##### 分组转发过程中，引起分组丢失的原因有哪些？
1. 数据链路层。帧检验序列校验失败。
2. 网络层。路由器输入输出的缓冲队列。

##### 数据链路层已经进行了差错校验，为什么 IP 和 TCP层还有检验和字段？

##### 网络层为什么不采用可靠实现？网络层实现可靠会带来什么问题？
1. 网络两两主机之间要实现虚电路，不利用计算机突发访问的特性。

结论：网络层不会采用虚电路技术，而采用分组交换。

##### 什么叫做面向流的概念？

##### TCP 发送数据的时机
+ MSS
+ UGT
+ 计时器

##### TCP 接收方发送 ACK 的时机

##### TCP 的传输效率为什么比 UDP 慢

##### 如何探索最小的 MTU
提示：利用 ICMP 差错报告报文实现

##### 在 sockopt 中如何设置能够更改 MSS、发送窗口、发送缓存 等值